<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC Scalping Monitor Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Oxanium:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.1/dist/chartjs-chart-financial.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>
    <style>
        :root {
            --bg-0: #06080a;
            --bg-1: #0c0f13;
            --bg-2: #12161c;
            --bg-3: #1a1f28;
            --border: #1e2530;
            --border-bright: #2a3140;
            --text-0: #e8ecf1;
            --text-1: #a0a8b8;
            --text-2: #6b7588;
            --text-3: #444e5f;
            --accent: #f7931a;
            --accent-dim: rgba(247, 147, 26, 0.15);
            --long: #00e676;
            --long-dim: rgba(0, 230, 118, 0.12);
            --long-glow: rgba(0, 230, 118, 0.4);
            --short: #ff1744;
            --short-dim: rgba(255, 23, 68, 0.12);
            --short-glow: rgba(255, 23, 68, 0.4);
            --warn: #ffc107;
            --info: #448aff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-0);
            color: var(--text-0);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
        }

        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: var(--bg-1); }
        ::-webkit-scrollbar-thumb { background: var(--border-bright); border-radius: 2px; }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: var(--bg-1);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            font-family: 'Oxanium', sans-serif;
            font-size: 15px;
            font-weight: 700;
            color: var(--accent);
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--long);
            box-shadow: 0 0 8px var(--long-glow);
            animation: pulse-dot 2s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .header-price {
            display: flex;
            align-items: baseline;
            gap: 12px;
        }

        .price-main {
            font-family: 'Oxanium', sans-serif;
            font-size: 22px;
            font-weight: 700;
            color: var(--text-0);
            letter-spacing: 1px;
        }

        .price-change {
            font-size: 12px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 3px;
        }

        .price-up { background: var(--long-dim); color: var(--long); }
        .price-down { background: var(--short-dim); color: var(--short); }

        .header-stats {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .stat-item { text-align: right; }
        .stat-label {
            font-size: 8px;
            color: var(--text-3);
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }
        .stat-value {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-1);
        }

        .main {
            display: grid;
            grid-template-columns: 290px 1fr 280px;
            gap: 1px;
            height: calc(100vh - 44px);
            background: var(--border);
        }

        .col {
            background: var(--bg-0);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .panel {
            border-bottom: 1px solid var(--border);
            padding: 10px;
        }

        .panel-title {
            font-family: 'Oxanium', sans-serif;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-3);
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-title .badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            padding: 2px 6px;
            border-radius: 2px;
            font-weight: 600;
        }

        .badge-live { background: var(--long-dim); color: var(--long); }

        .signal-card {
            background: var(--bg-2);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 6px;
            transition: border-color 0.3s;
            cursor: pointer;
        }

        .signal-card.active-long {
            border-color: var(--long);
            box-shadow: 0 0 15px var(--long-dim);
        }

        .signal-card.active-short {
            border-color: var(--short);
            box-shadow: 0 0 15px var(--short-dim);
        }

        .signal-card:hover {
            border-color: var(--border-bright);
        }

        .signal-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .signal-direction {
            font-family: 'Oxanium', sans-serif;
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .signal-quality {
            font-size: 9px;
            font-weight: 700;
            padding: 2px 8px;
            border-radius: 2px;
            letter-spacing: 1px;
        }

        .quality-a { background: var(--long); color: #000; }
        .quality-b { background: var(--warn); color: #000; }
        .quality-c { background: var(--text-3); color: var(--text-1); }
        .quality-none { background: var(--bg-3); color: var(--text-3); }

        .signal-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            font-size: 10px;
        }

        .signal-row .label { color: var(--text-2); }
        .signal-row .value { font-weight: 500; color: var(--text-0); }
        .signal-row .value.long { color: var(--long); }
        .signal-row .value.short { color: var(--short); }
        .signal-row .value.warn { color: var(--warn); }
        .signal-row .value.dim { color: var(--text-2); }

        .chart-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .chart-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: var(--bg-1);
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
            gap: 6px;
        }

        .toolbar-left {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .toolbar-right {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .tf-group {
            display: flex;
            gap: 2px;
        }

        .tf-btn {
            background: var(--bg-2);
            border: 1px solid var(--border);
            color: var(--text-2);
            padding: 4px 8px;
            cursor: pointer;
            font-family: 'Oxanium', sans-serif;
            font-size: 10px;
            font-weight: 600;
            border-radius: 2px;
            transition: all 0.2s;
        }

        .tf-btn:hover { border-color: var(--text-3); color: var(--text-1); }
        .tf-btn.active { background: var(--accent); color: #000; border-color: var(--accent); }

        .chart-toggles {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .toggle-chip {
            font-size: 9px;
            color: var(--text-2);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            user-select: none;
            padding: 3px 6px;
            border-radius: 2px;
            border: 1px solid transparent;
            transition: all 0.2s;
        }

        .toggle-chip:hover { border-color: var(--border-bright); }
        .toggle-chip.on { color: var(--text-0); border-color: var(--border-bright); background: var(--bg-3); }

        .toggle-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .chart-type-group {
            display: flex;
            gap: 2px;
        }

        .chart-type-btn {
            background: var(--bg-2);
            border: 1px solid var(--border);
            color: var(--text-2);
            padding: 4px 10px;
            cursor: pointer;
            font-family: 'Oxanium', sans-serif;
            font-size: 9px;
            font-weight: 600;
            border-radius: 2px;
            transition: all 0.2s;
        }

        .chart-type-btn:hover { border-color: var(--text-3); color: var(--text-1); }
        .chart-type-btn.active { background: var(--bg-3); color: var(--text-0); border-color: var(--text-2); }

        .chart-wrap {
            flex: 1;
            position: relative;
            min-height: 0;
            background: var(--bg-0);
            cursor: crosshair;
        }

        .chart-wrap canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .chart-hint {
            position: absolute;
            bottom: 8px;
            left: 8px;
            font-size: 8px;
            color: var(--text-3);
            pointer-events: none;
            z-index: 10;
        }

        .fvg-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: var(--bg-2);
            border-radius: 3px;
            margin-bottom: 3px;
            font-size: 10px;
            border-left: 3px solid transparent;
        }

        .fvg-item.bull { border-left-color: var(--long); }
        .fvg-item.bear { border-left-color: var(--short); }

        .fvg-tag {
            font-size: 8px;
            font-weight: 600;
            padding: 1px 5px;
            border-radius: 2px;
            letter-spacing: 0.5px;
        }

        .tag-open { background: var(--long-dim); color: var(--long); }
        .tag-partial { background: rgba(255,193,7,0.15); color: var(--warn); }

        .wyckoff-bar {
            display: flex;
            gap: 3px;
            margin: 6px 0;
        }

        .wk-phase {
            flex: 1;
            height: 4px;
            background: var(--bg-3);
            border-radius: 2px;
            overflow: hidden;
        }

        .wk-phase.active {
            background: var(--accent);
            box-shadow: 0 0 8px var(--accent-dim);
        }

        .wk-phase.current { animation: wk-pulse 1.5s infinite; }

        @keyframes wk-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .liq-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            font-size: 10px;
        }

        .liq-bar-wrap {
            flex: 1;
            height: 4px;
            background: var(--bg-3);
            border-radius: 2px;
            overflow: hidden;
        }

        .liq-bar-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.5s;
        }

        .liq-bar-fill.above { background: linear-gradient(90deg, var(--short), #ff6e40); }
        .liq-bar-fill.below { background: linear-gradient(90deg, var(--long), #69f0ae); }

        .history-item {
            display: grid;
            grid-template-columns: 50px 1fr 60px 50px;
            gap: 6px;
            padding: 5px 8px;
            background: var(--bg-2);
            border-radius: 3px;
            margin-bottom: 3px;
            font-size: 9px;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .history-item:hover {
            background: var(--bg-3);
            border-color: var(--border-bright);
        }

        .mtf-row {
            display: grid;
            grid-template-columns: 40px 1fr 60px;
            gap: 8px;
            padding: 4px 0;
            align-items: center;
            font-size: 10px;
            border-bottom: 1px solid var(--border);
        }

        .mtf-tf { font-weight: 600; color: var(--text-2); }

        .mtf-bar-wrap {
            height: 6px;
            background: var(--bg-3);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .mtf-bar-center {
            position: absolute;
            left: 50%;
            top: 0;
            width: 1px;
            height: 100%;
            background: var(--text-3);
        }

        .mtf-bar-fill {
            height: 100%;
            border-radius: 3px;
            transition: all 0.5s;
            position: absolute;
            top: 0;
        }

        .alert-toast {
            position: fixed;
            top: 52px;
            right: 12px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 6px;
            pointer-events: none;
        }

        .toast {
            background: var(--bg-1);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 10px 14px;
            min-width: 300px;
            pointer-events: auto;
            animation: slide-in 0.3s ease-out;
            border-left: 3px solid;
        }

        .toast.long-toast { border-left-color: var(--long); }
        .toast.short-toast { border-left-color: var(--short); }
        .toast.info-toast { border-left-color: var(--info); }
        .toast.fvg-toast { border-left-color: var(--accent); }

        @keyframes slide-in {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .toast-title {
            font-family: 'Oxanium', sans-serif;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 3px;
        }

        .toast-body { font-size: 10px; color: var(--text-2); line-height: 1.4; }
        .toast-time { font-size: 8px; color: var(--text-3); margin-top: 4px; }

        .bt-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }

        .bt-cell {
            background: var(--bg-2);
            padding: 6px;
            border-radius: 3px;
            text-align: center;
        }

        .bt-cell .bt-label {
            font-size: 7px;
            color: var(--text-3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .bt-cell .bt-value {
            font-size: 13px;
            font-weight: 600;
            margin-top: 2px;
        }

        .cooldown-bar {
            width: 100%;
            height: 3px;
            background: var(--bg-3);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 6px;
        }

        .cooldown-fill {
            height: 100%;
            background: var(--accent);
            transition: width 1s linear;
        }

        .loading-overlay {
            position: fixed;
            inset: 0;
            background: var(--bg-0);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s;
        }

        .loading-overlay.hidden { opacity: 0; pointer-events: none; }

        .loading-text {
            font-family: 'Oxanium', sans-serif;
            font-size: 14px;
            color: var(--accent);
            letter-spacing: 3px;
            margin-top: 16px;
        }

        .loading-sub { font-size: 10px; color: var(--text-3); margin-top: 6px; }

        .loading-spinner {
            width: 40px; height: 40px;
            border: 2px solid var(--border);
            border-top: 2px solid var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(6,8,10,0.85);
            backdrop-filter: blur(4px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-overlay.active { display: flex; }

        .modal-content {
            background: var(--bg-1);
            border: 1px solid var(--border);
            border-radius: 6px;
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-family: 'Oxanium', sans-serif;
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-2);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .modal-close:hover {
            background: var(--bg-2);
            color: var(--text-0);
        }

        .modal-body {
            padding: 20px;
        }

        .modal-section {
            margin-bottom: 16px;
        }

        .modal-section-title {
            font-size: 9px;
            color: var(--text-3);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 8px;
        }

        .modal-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid var(--border);
            font-size: 11px;
        }

        .modal-row:last-child { border-bottom: none; }

        .modal-label { color: var(--text-2); }
        .modal-value { font-weight: 600; }

        .load-more-btn {
            width: 100%;
            padding: 8px;
            background: var(--bg-2);
            border: 1px solid var(--border);
            color: var(--text-2);
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            cursor: pointer;
            border-radius: 3px;
            margin-top: 8px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .load-more-btn:hover {
            background: var(--bg-3);
            color: var(--text-1);
            border-color: var(--border-bright);
        }

        .load-more-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pnl-positive { color: var(--long); }
        .pnl-negative { color: var(--short); }
    </style>
</head>
<body>

<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div class="loading-text">INITIALISIERUNG</div>
    <div class="loading-sub" id="loadingStatus">Lade Marktdaten...</div>
</div>

<div class="alert-toast" id="toastContainer"></div>

<div class="modal-overlay" id="signalModal">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="modalTitle">Signal Details</div>
            <button class="modal-close" onclick="closeModal()">×</button>
        </div>
        <div class="modal-body" id="modalBody">
            <!-- Content injected via JS -->
        </div>
    </div>
</div>

<div class="header">
    <div class="logo">
        <div class="logo-dot" id="wsStatus"></div>
        BTC SCALPING MONITOR
    </div>
    <div class="header-price">
        <span class="price-main" id="livePrice">--</span>
        <span class="price-change price-up" id="priceChange">0.00%</span>
    </div>
    <div class="header-stats">
        <div class="stat-item">
            <div class="stat-label">HTF Bias</div>
            <div class="stat-value" id="htfBias" style="color:var(--text-2)">--</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Signale heute</div>
            <div class="stat-value" id="signalCount">0</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Win Rate (Live)</div>
            <div class="stat-value" id="liveWinRate" style="color:var(--accent)">--</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Wyckoff</div>
            <div class="stat-value" id="headerWyckoff" style="color:var(--text-2)">--</div>
        </div>
    </div>
</div>

<div class="main">
    <!-- LEFT COLUMN -->
    <div class="col">
        <div class="panel">
            <div class="panel-title">Multi-Timeframe Bias <span class="badge badge-live">LIVE</span></div>
            <div id="mtfContainer"></div>
        </div>

        <div class="panel">
            <div class="panel-title">Wyckoff Phase</div>
            <div class="signal-row"><span class="label">Phase</span><span class="value" id="wkPhase">--</span></div>
            <div class="signal-row"><span class="label">Sub-Phase</span><span class="value" id="wkSubPhase">--</span></div>
            <div class="wyckoff-bar" id="wkBar">
                <div class="wk-phase" data-p="A"></div>
                <div class="wk-phase" data-p="B"></div>
                <div class="wk-phase" data-p="C"></div>
                <div class="wk-phase" data-p="D"></div>
                <div class="wk-phase" data-p="E"></div>
            </div>
            <div class="signal-row"><span class="label">Spring/Upthrust</span><span class="value" id="wkSpring">--</span></div>
            <div class="signal-row"><span class="label">Volume Confirm</span><span class="value" id="wkVolConf">--</span></div>
            <div class="signal-row"><span class="label">Structure</span><span class="value" id="wkStructure">--</span></div>
        </div>

        <div class="panel">
            <div class="panel-title">Fair Value Gaps <span class="badge" id="fvgCount" style="background:var(--bg-3);color:var(--text-2)">0</span></div>
            <div id="fvgList"></div>
        </div>

        <div class="panel">
            <div class="panel-title">Liquiditäts-Cluster</div>
            <div id="liqList"></div>
        </div>

        <div class="panel">
            <div class="panel-title">Backtest Performance</div>
            <div class="bt-grid">
                <div class="bt-cell"><div class="bt-label">Win Rate</div><div class="bt-value" id="btWinRate" style="color:var(--text-2)">--</div></div>
                <div class="bt-cell"><div class="bt-label">Profit Factor</div><div class="bt-value" id="btPF" style="color:var(--text-2)">--</div></div>
                <div class="bt-cell"><div class="bt-label">Avg R:R</div><div class="bt-value" id="btRR" style="color:var(--text-2)">--</div></div>
                <div class="bt-cell"><div class="bt-label">Max DD</div><div class="bt-value" id="btDD" style="color:var(--text-2)">--</div></div>
            </div>
        </div>
    </div>

    <!-- CENTER: CHART -->
    <div class="col">
        <div class="chart-area">
            <div class="chart-toolbar">
                <div class="toolbar-left">
                    <div class="tf-group">
                        <button class="tf-btn" data-tf="1m">1m</button>
                        <button class="tf-btn" data-tf="3m">3m</button>
                        <button class="tf-btn" data-tf="5m">5m</button>
                        <button class="tf-btn" data-tf="15m">15m</button>
                        <button class="tf-btn" data-tf="30m">30m</button>
                        <button class="tf-btn" data-tf="1h">1h</button>
                        <button class="tf-btn" data-tf="2h">2h</button>
                        <button class="tf-btn active" data-tf="4h">4h</button>
                    </div>
                    <div class="chart-type-group">
                        <button class="chart-type-btn" id="btnLine">Line</button>
                        <button class="chart-type-btn active" id="btnCandles">Candles</button>
                    </div>
                </div>
                <div class="toolbar-right">
                    <div class="chart-toggles">
                        <div class="toggle-chip on" data-overlay="ema">
                            <div class="toggle-dot" style="background:var(--long)"></div>EMA
                        </div>
                        <div class="toggle-chip on" data-overlay="fvg">
                            <div class="toggle-dot" style="background:var(--accent)"></div>FVG
                        </div>
                        <div class="toggle-chip on" data-overlay="ob">
                            <div class="toggle-dot" style="background:var(--info)"></div>OB
                        </div>
                        <div class="toggle-chip" data-overlay="mss">
                            <div class="toggle-dot" style="background:#e040fb"></div>MSS
                        </div>
                        <div class="toggle-chip" data-overlay="liq">
                            <div class="toggle-dot" style="background:var(--warn)"></div>LIQ
                        </div>
                    </div>
                </div>
            </div>
            <div class="chart-wrap">
                <canvas id="mainChart"></canvas>
                <div class="chart-hint">Scroll: Zoom | Drag: Pan | Dbl-Click: Reset</div>
            </div>
        </div>
    </div>

    <!-- RIGHT COLUMN -->
    <div class="col">
        <div class="panel">
            <div class="panel-title">Aktives Signal <span class="badge" id="signalBadge" style="background:var(--bg-3);color:var(--text-3)">KEIN SIGNAL</span></div>
            <div class="signal-card" id="activeSignalCard">
                <div class="signal-card-header">
                    <span class="signal-direction" id="sigDirection" style="color:var(--text-3)">WARTE...</span>
                    <span class="signal-quality quality-none" id="sigQuality">--</span>
                </div>
                <div class="signal-row"><span class="label">Entry</span><span class="value" id="sigEntry">--</span></div>
                <div class="signal-row"><span class="label">Stop Loss</span><span class="value" id="sigSL">--</span></div>
                <div class="signal-row"><span class="label">TP1</span><span class="value" id="sigTP1">--</span></div>
                <div class="signal-row"><span class="label">TP2</span><span class="value" id="sigTP2">--</span></div>
                <div class="signal-row"><span class="label">R:R</span><span class="value" id="sigRR">--</span></div>
                <div class="signal-row"><span class="label">Confluence</span><span class="value" id="sigConf">--</span></div>
                <div class="signal-row"><span class="label">Grund</span><span class="value" id="sigReason">--</span></div>
                <div class="cooldown-bar"><div class="cooldown-fill" id="cooldownFill" style="width:0%"></div></div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">Confluence Check</div>
            <div class="signal-row"><span class="label">HTF Bias Align</span><span class="value" id="cfHTF">--</span></div>
            <div class="signal-row"><span class="label">FVG Entry</span><span class="value" id="cfFVG">--</span></div>
            <div class="signal-row"><span class="label">Order Block</span><span class="value" id="cfOB">--</span></div>
            <div class="signal-row"><span class="label">MSS / BOS</span><span class="value" id="cfMSS">--</span></div>
            <div class="signal-row"><span class="label">Wyckoff Phase</span><span class="value" id="cfWyckoff">--</span></div>
            <div class="signal-row"><span class="label">Liq Sweep</span><span class="value" id="cfLiq">--</span></div>
            <div class="signal-row"><span class="label">Volume Confirm</span><span class="value" id="cfVol">--</span></div>
        </div>

        <div class="panel">
            <div class="panel-title">Market Structure</div>
            <div class="signal-row"><span class="label">Trend (LTF)</span><span class="value" id="mssTrend">--</span></div>
            <div class="signal-row"><span class="label">Letzter MSS</span><span class="value" id="mssLast">--</span></div>
            <div class="signal-row"><span class="label">Letzter BOS</span><span class="value" id="bosLast">--</span></div>
            <div class="signal-row"><span class="label">Swing High</span><span class="value" id="mssSwH">--</span></div>
            <div class="signal-row"><span class="label">Swing Low</span><span class="value" id="mssSwL">--</span></div>
        </div>

        <div class="panel">
            <div class="panel-title">Signal-Historie <span class="badge" id="histBadge" style="background:var(--bg-3);color:var(--text-2)">0</span></div>
            <div id="signalHistory" style="max-height: 300px; overflow-y: auto;">
                <div style="text-align:center;color:var(--text-3);padding:12px;font-size:10px;">Noch keine Signale</div>
            </div>
            <button class="load-more-btn" id="loadMoreBtn" style="display:none;" onclick="loadMoreHistory()">Mehr laden</button>
        </div>
    </div>
</div>

<script>
// ============================================================
// STATE
// ============================================================
const STATE = {
    price: 0,
    openPrice24h: 0,
    ws: null,
    wsReconnectTimer: null,
    chart: null,
    currentTF: '4h',
    chartType: 'candles',

    // Overlay toggles
    overlays: { ema: true, fvg: true, ob: true, mss: false, liq: false },

    tfData: {},
    tfBias: {},

    fvgs: [],
    orderBlocks: [],
    swingPoints: [],
    liquidityLevels: [],
    mssEvents: [],
    bosEvents: [],
    currentTrend: 'neutral',
    wyckoff: { phase: 'none', subPhase: '', confidence: 0 },

    activeSignal: null,
    signalHistory: [],
    signalCooldown: 0,
    COOLDOWN_MS: 4 * 60 * 60 * 1000, // 4 Stunden Cooldown für höhere Qualität
    signalCount: 0,
    btResults: null,
    
    // Pagination für Signal-Historie
    historyPage: 0,
    historyPerPage: 10,
};

// ============================================================
// DATA
// ============================================================
async function fetchCandles(interval, limit = 500) {
    try {
        const res = await fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${interval}&limit=${limit}`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        if (!data || !data.length) return null;
        return data.map(d => ({ t: d[0], o: +d[1], h: +d[2], l: +d[3], c: +d[4], v: +d[5] }));
    } catch (e) { console.error(`Fetch ${interval}:`, e); return null; }
}

async function loadAllTimeframes() {
    const tfs = ['5m', '15m', '30m', '1h', '2h', '4h'];
    const results = await Promise.all(tfs.map(tf => fetchCandles(tf, 500)));
    tfs.forEach((tf, i) => { if (results[i]) STATE.tfData[tf] = results[i]; });

    if (!STATE.tfData[STATE.currentTF]) {
        const d = await fetchCandles(STATE.currentTF, 500);
        if (d) STATE.tfData[STATE.currentTF] = d;
    }

    const ref = STATE.tfData['4h'] || STATE.tfData['1h'] || STATE.tfData['5m'];
    if (ref && ref.length) STATE.price = ref[ref.length - 1].c;

    if (STATE.tfData['1h'] && STATE.tfData['1h'].length >= 24) {
        STATE.openPrice24h = STATE.tfData['1h'][STATE.tfData['1h'].length - 24].o;
    }
}

// ============================================================
// MATH HELPERS
// ============================================================
function calcEMA(data, period) {
    if (!data.length) return [];
    const k = 2 / (period + 1);
    const ema = [data[0]];
    for (let i = 1; i < data.length; i++) ema.push(data[i] * k + ema[i - 1] * (1 - k));
    return ema;
}

function calcATR(candles, period = 14) {
    const atr = [];
    for (let i = 0; i < candles.length; i++) {
        const tr = i === 0 ? candles[i].h - candles[i].l :
            Math.max(candles[i].h - candles[i].l, Math.abs(candles[i].h - candles[i-1].c), Math.abs(candles[i].l - candles[i-1].c));
        atr.push(i < period ? tr : (atr[i-1] * (period - 1) + tr) / period);
    }
    return atr;
}

// ============================================================
// MTF BIAS
// ============================================================
function analyzeMTFBias() {
    const tfs = ['5m', '15m', '30m', '1h', '2h', '4h'];
    tfs.forEach(tf => {
        const data = STATE.tfData[tf];
        if (!data || data.length < 100) { STATE.tfBias[tf] = { bias: 'neutral', strength: 0, score: 0 }; return; }
        const closes = data.map(d => d.c);
        const ema20 = calcEMA(closes, 20), ema50 = calcEMA(closes, 50), ema100 = calcEMA(closes, 100);
        const L = closes.length - 1, price = closes[L];
        let score = 0;
        if (ema20[L] > ema50[L] && ema50[L] > ema100[L]) score += 4;
        else if (ema20[L] < ema50[L] && ema50[L] < ema100[L]) score -= 4;
        if (price > ema20[L]) score += 1; else score -= 1;
        if (price > ema50[L]) score += 1; else score -= 1;
        if (price > ema100[L]) score += 1; else score -= 1;
        const bullC = data.slice(-5).filter(c => c.c > c.o).length;
        score += (bullC - 2.5);
        const strength = Math.min(100, Math.abs(score / 10) * 100);
        STATE.tfBias[tf] = { bias: score > 2 ? 'bullish' : score < -2 ? 'bearish' : 'neutral', strength, score };
    });
    const weights = { '4h': 4, '2h': 3, '1h': 2.5, '30m': 2, '15m': 1.5, '5m': 0.5 };
    let ts = 0, tw = 0;
    tfs.forEach(tf => { if (STATE.tfBias[tf]) { ts += STATE.tfBias[tf].score * (weights[tf]||1); tw += weights[tf]||1; }});
    const h = tw > 0 ? ts / tw : 0;
    STATE.htfBias = h > 1.5 ? 'BULLISH' : h < -1.5 ? 'BEARISH' : 'NEUTRAL';
}

function renderMTFBias() {
    const el = document.getElementById('mtfContainer');
    const tfs = ['5m', '15m', '30m', '1h', '2h', '4h'];
    el.innerHTML = tfs.map(tf => {
        const b = STATE.tfBias[tf] || { bias: 'neutral', strength: 0, score: 0 };
        const col = b.bias === 'bullish' ? 'var(--long)' : b.bias === 'bearish' ? 'var(--short)' : 'var(--text-3)';
        const pct = Math.min(50, b.strength / 2);
        const left = b.score > 0 ? '50%' : `${50 - pct}%`;
        return `<div class="mtf-row"><span class="mtf-tf">${tf}</span>
            <div class="mtf-bar-wrap"><div class="mtf-bar-center"></div>
            <div class="mtf-bar-fill" style="left:${left};width:${pct}%;background:${col}"></div></div>
            <span style="color:${col};font-weight:600;text-align:right">${b.bias.toUpperCase()}</span></div>`;
    }).join('');
    const htf = document.getElementById('htfBias');
    htf.textContent = STATE.htfBias;
    htf.style.color = STATE.htfBias === 'BULLISH' ? 'var(--long)' : STATE.htfBias === 'BEARISH' ? 'var(--short)' : 'var(--text-2)';
}

// ============================================================
// SWING POINTS & MSS/BOS
// ============================================================
function detectSwingPoints(candles, lb = 3) {
    const sw = [];
    for (let i = lb; i < candles.length - lb; i++) {
        let isH = true, isL = true;
        for (let j = 1; j <= lb; j++) {
            if (candles[i].h <= candles[i-j].h || candles[i].h <= candles[i+j].h) isH = false;
            if (candles[i].l >= candles[i-j].l || candles[i].l >= candles[i+j].l) isL = false;
        }
        if (isH) sw.push({ type: 'high', price: candles[i].h, index: i, time: candles[i].t });
        if (isL) sw.push({ type: 'low', price: candles[i].l, index: i, time: candles[i].t });
    }
    return sw;
}

function detectMSSandBOS(candles) {
    const swings = detectSwingPoints(candles, 3);
    STATE.swingPoints = swings;
    STATE.mssEvents = [];
    STATE.bosEvents = [];
    let lastH = null, lastL = null, trend = 'neutral';

    for (const sw of swings) {
        if (sw.type === 'high') {
            if (lastH) {
                if (sw.price > lastH.price) {
                    if (trend === 'bearish') STATE.mssEvents.push({ type: 'MSS_BULL', price: sw.price, time: sw.time, index: sw.index });
                    else STATE.bosEvents.push({ type: 'BOS_BULL', price: sw.price, time: sw.time, index: sw.index });
                    trend = 'bullish';
                } else if (trend === 'bullish') {
                    STATE.mssEvents.push({ type: 'MSS_BEAR', price: sw.price, time: sw.time, index: sw.index });
                    trend = 'bearish';
                }
            }
            lastH = sw;
        } else {
            if (lastL) {
                if (sw.price < lastL.price) {
                    if (trend === 'bullish') STATE.mssEvents.push({ type: 'MSS_BEAR', price: sw.price, time: sw.time, index: sw.index });
                    else STATE.bosEvents.push({ type: 'BOS_BEAR', price: sw.price, time: sw.time, index: sw.index });
                    trend = 'bearish';
                } else if (trend === 'bearish') {
                    STATE.mssEvents.push({ type: 'MSS_BULL', price: sw.price, time: sw.time, index: sw.index });
                    trend = 'bullish';
                }
            }
            lastL = sw;
        }
    }
    STATE.currentTrend = trend;

    document.getElementById('mssTrend').textContent = trend.toUpperCase();
    document.getElementById('mssTrend').style.color = trend === 'bullish' ? 'var(--long)' : trend === 'bearish' ? 'var(--short)' : 'var(--text-2)';
    const lm = STATE.mssEvents[STATE.mssEvents.length - 1];
    const lb = STATE.bosEvents[STATE.bosEvents.length - 1];
    if (lm) { document.getElementById('mssLast').textContent = `${lm.type.replace('_',' ')} @ $${lm.price.toFixed(0)}`; document.getElementById('mssLast').style.color = lm.type.includes('BULL') ? 'var(--long)' : 'var(--short)'; }
    if (lb) { document.getElementById('bosLast').textContent = `${lb.type.replace('_',' ')} @ $${lb.price.toFixed(0)}`; document.getElementById('bosLast').style.color = lb.type.includes('BULL') ? 'var(--long)' : 'var(--short)'; }
    if (lastH) { document.getElementById('mssSwH').textContent = '$' + lastH.price.toFixed(0); document.getElementById('mssSwH').style.color = 'var(--short)'; }
    if (lastL) { document.getElementById('mssSwL').textContent = '$' + lastL.price.toFixed(0); document.getElementById('mssSwL').style.color = 'var(--long)'; }
}

// ============================================================
// FVG - Verbessert: Signifikantere Gaps (>1%)
// ============================================================
function detectFVGs(candles) {
    const fvgs = [];
    for (let i = 2; i < candles.length; i++) {
        const p = candles[i-2], c = candles[i];
        // Erhöhter Threshold auf 1% für signifikantere FVGs
        if (c.l > p.h && (c.l - p.h) / p.h >= 0.01) fvgs.push({ type: 'bullish', top: c.l, bottom: p.h, idx: i, time: c.t, status: 'open', filled: 0 });
        if (c.h < p.l && (p.l - c.h) / p.l >= 0.01) fvgs.push({ type: 'bearish', top: p.l, bottom: c.h, idx: i, time: c.t, status: 'open', filled: 0 });
    }
    fvgs.forEach(f => {
        for (let i = f.idx + 1; i < candles.length; i++) {
            const c = candles[i];
            if (f.type === 'bullish') {
                if (c.l <= f.bottom) { f.status = 'filled'; f.filled = 1; break; }
                if (c.l < f.top) f.filled = Math.max(f.filled, (f.top - c.l) / (f.top - f.bottom));
            } else {
                if (c.h >= f.top) { f.status = 'filled'; f.filled = 1; break; }
                if (c.h > f.bottom) f.filled = Math.max(f.filled, (c.h - f.bottom) / (f.top - f.bottom));
            }
        }
        if (f.filled >= 0.7 && f.status !== 'filled') f.status = 'partial';
    });
    STATE.fvgs = fvgs.filter(f => f.status !== 'filled');
}

function renderFVGList() {
    const el = document.getElementById('fvgList');
    const open = STATE.fvgs.filter(f => f.status !== 'filled').slice(-8);
    document.getElementById('fvgCount').textContent = open.length;
    if (!open.length) { el.innerHTML = '<div style="text-align:center;color:var(--text-3);padding:8px;font-size:10px">Keine offenen FVGs</div>'; return; }
    el.innerHTML = open.map(f => {
        const dist = f.type === 'bullish' ? ((STATE.price - f.top) / STATE.price * 100).toFixed(2) : ((f.bottom - STATE.price) / STATE.price * 100).toFixed(2);
        return `<div class="fvg-item ${f.type === 'bullish' ? 'bull' : 'bear'}"><span>$${f.bottom.toFixed(0)} – $${f.top.toFixed(0)}</span><span style="color:var(--text-2)">${dist}%</span><span class="fvg-tag ${f.status === 'open' ? 'tag-open' : 'tag-partial'}">${f.status.toUpperCase()}</span></div>`;
    }).join('');
}

// ============================================================
// ORDER BLOCKS
// ============================================================
function detectOrderBlocks(candles) {
    STATE.orderBlocks = [];
    for (let i = 2; i < candles.length - 1; i++) {
        const c0 = candles[i-1], c1 = candles[i], c2 = candles[i+1];
        if (c0.c < c0.o && c1.c > c1.o && (c1.c - c1.o) / c1.o > 0.002 && c2.c > c1.h)
            STATE.orderBlocks.push({ type: 'bullish', high: c0.h, low: c0.l, idx: i-1, time: c0.t, mitigated: false });
        if (c0.c > c0.o && c1.c < c1.o && (c1.o - c1.c) / c1.o > 0.002 && c2.c < c1.l)
            STATE.orderBlocks.push({ type: 'bearish', high: c0.h, low: c0.l, idx: i-1, time: c0.t, mitigated: false });
    }
    STATE.orderBlocks.forEach(ob => {
        for (let i = ob.idx + 3; i < candles.length; i++) {
            if (ob.type === 'bullish' && candles[i].l < ob.low) { ob.mitigated = true; break; }
            if (ob.type === 'bearish' && candles[i].h > ob.high) { ob.mitigated = true; break; }
        }
    });
    STATE.orderBlocks = STATE.orderBlocks.filter(ob => !ob.mitigated).slice(-10);
}

// ============================================================
// LIQUIDITY
// ============================================================
function detectLiquidityLevels() {
    STATE.liquidityLevels = [];
    const highs = STATE.swingPoints.filter(s => s.type === 'high').map(s => s.price);
    const lows = STATE.swingPoints.filter(s => s.type === 'low').map(s => s.price);

    function cluster(lvls, tol = 0.001) {
        const cl = [], used = new Set();
        for (let i = 0; i < lvls.length; i++) {
            if (used.has(i)) continue;
            let g = [lvls[i]];
            for (let j = i+1; j < lvls.length; j++) { if (!used.has(j) && Math.abs(lvls[j] - lvls[i]) / lvls[i] < tol) { g.push(lvls[j]); used.add(j); }}
            if (g.length >= 2) cl.push({ price: g.reduce((a,b)=>a+b,0)/g.length, touches: g.length });
            used.add(i);
        }
        return cl;
    }

    const eqH = cluster(highs).map(c => ({ ...c, type: 'EQH' }));
    const eqL = cluster(lows).map(c => ({ ...c, type: 'EQL' }));
    if (highs.length) eqH.push({ price: Math.max(...highs.slice(-10)), touches: 1, type: 'BSL' });
    if (lows.length) eqL.push({ price: Math.min(...lows.slice(-10)), touches: 1, type: 'SSL' });

    STATE.liquidityLevels = [...eqH, ...eqL].sort((a, b) => Math.abs(a.price - STATE.price) - Math.abs(b.price - STATE.price)).slice(0, 8);
}

function renderLiquidity() {
    const el = document.getElementById('liqList');
    if (!STATE.liquidityLevels.length) { el.innerHTML = '<div style="text-align:center;color:var(--text-3);padding:8px;font-size:10px">Keine Cluster</div>'; return; }
    const mx = Math.max(...STATE.liquidityLevels.map(l => l.touches));
    el.innerHTML = STATE.liquidityLevels.map(l => {
        const dist = ((l.price / STATE.price - 1) * 100).toFixed(2);
        const above = l.price > STATE.price;
        return `<div class="liq-row"><span style="color:${above ? 'var(--short)' : 'var(--long)'};font-weight:600;min-width:45px">${l.type}</span><span style="min-width:70px">$${l.price.toFixed(0)}</span><div class="liq-bar-wrap"><div class="liq-bar-fill ${above ? 'above' : 'below'}" style="width:${(l.touches/mx*100).toFixed(0)}%"></div></div><span style="color:var(--text-2);min-width:45px;text-align:right">${dist}%</span></div>`;
    }).join('');
}

// ============================================================
// WYCKOFF
// ============================================================
function analyzeWyckoff() {
    const data = STATE.tfData['1h'] || STATE.tfData['30m'];
    if (!data || data.length < 60) { STATE.wyckoff = { phase: 'none', subPhase: '', confidence: 0 }; return; }
    const rec = data.slice(-80);
    const highs = rec.map(d => d.h), lows = rec.map(d => d.l), closes = rec.map(d => d.c), vols = rec.map(d => d.v);
    const maxH = Math.max(...highs), minL = Math.min(...lows), range = maxH - minL;
    if (range === 0) return;
    const last = closes[closes.length-1], pos = (last - minL) / range;
    const avgV = vols.reduce((a,b)=>a+b,0)/vols.length, recV = vols.slice(-5).reduce((a,b)=>a+b,0)/5, vr = recV/avgV;
    const isRange = range / minL < 0.08;
    let phase = 'none', sub = '', conf = 0;
    const pc = closes[closes.length-2], p2 = closes[closes.length-3];
    const revUp = last > pc && pc < p2, revDown = last < pc && pc > p2;

    if (isRange) {
        if (pos < 0.15 && vr > 1.3 && revUp) { phase = 'accumulation'; sub = 'Spring'; conf = Math.min(90, vr*40); }
        else if (pos < 0.2 && vr < 1.0 && revUp) { phase = 'accumulation'; sub = 'Test'; conf = 50; }
        else if (pos > 0.85 && vr > 1.2) { phase = 'accumulation'; sub = 'SOS'; conf = Math.min(80, vr*35); }
        else if (pos > 0.85 && vr > 1.3 && revDown) { phase = 'distribution'; sub = 'Upthrust'; conf = Math.min(90, vr*40); }
        else if (pos > 0.8 && vr < 1.0 && revDown) { phase = 'distribution'; sub = 'LPSY'; conf = 50; }
        else if (pos < 0.15 && vr > 1.2) { phase = 'distribution'; sub = 'SOW'; conf = Math.min(80, vr*35); }
        else if (pos < 0.4) { phase = 'accumulation'; sub = 'Range'; conf = 30; }
        else if (pos > 0.6) { phase = 'distribution'; sub = 'Range'; conf = 30; }
    }
    STATE.wyckoff = { phase, subPhase: sub, confidence: conf, posInRange: pos, volRatio: vr };

    const wkP = document.getElementById('wkPhase'), wkS = document.getElementById('wkSubPhase'), hdr = document.getElementById('headerWyckoff');
    if (phase === 'accumulation') { wkP.textContent = 'Akkumulation'; wkP.style.color = 'var(--long)'; hdr.textContent = 'AKK '+sub; hdr.style.color = 'var(--long)'; }
    else if (phase === 'distribution') { wkP.textContent = 'Distribution'; wkP.style.color = 'var(--short)'; hdr.textContent = 'DIST '+sub; hdr.style.color = 'var(--short)'; }
    else { wkP.textContent = 'Neutral'; wkP.style.color = 'var(--text-2)'; hdr.textContent = '--'; hdr.style.color = 'var(--text-2)'; }
    wkS.textContent = sub || '--'; wkS.style.color = sub ? (phase === 'accumulation' ? 'var(--long)' : 'var(--short)') : 'var(--text-2)';
    const pm = { 'Range':'B','Spring':'C','Test':'C','SOS':'D','Upthrust':'C','LPSY':'C','SOW':'D' };
    const ap = pm[sub] || 'A';
    document.querySelectorAll('#wkBar .wk-phase').forEach(e => { e.classList.remove('active','current'); if (phase !== 'none' && e.dataset.p <= ap) e.classList.add('active'); if (phase !== 'none' && e.dataset.p === ap) e.classList.add('current'); });
    document.getElementById('wkSpring').textContent = (sub === 'Spring' || sub === 'Upthrust') ? '✓ '+sub : '--';
    document.getElementById('wkSpring').style.color = (sub === 'Spring' || sub === 'Upthrust') ? 'var(--long)' : 'var(--text-3)';
    document.getElementById('wkVolConf').textContent = vr > 1.2 ? `✓ ${vr.toFixed(1)}x` : `${vr.toFixed(1)}x`;
    document.getElementById('wkVolConf').style.color = vr > 1.2 ? 'var(--long)' : 'var(--text-3)';
    document.getElementById('wkStructure').textContent = isRange ? 'Range-bound' : 'Trending';
    document.getElementById('wkStructure').style.color = isRange ? 'var(--warn)' : 'var(--text-2)';
}

// ============================================================
// SIGNAL GENERATION - Verbessert: Höhere Qualität, weniger Signale
// ============================================================
function generateSignals() {
    const candles = STATE.tfData[STATE.currentTF];
    if (!candles || candles.length < 50) return;
    if (Date.now() < STATE.signalCooldown) { updateCooldownBar(); return; }

    const price = STATE.price, atr = calcATR(candles, 14), atrVal = atr[atr.length-1];
    let ls = 0, ss = 0, reasons = { long: [], short: [] };

    // 1. HTF Bias (2pts) - MUSS klar sein, nicht neutral
    if (STATE.htfBias === 'BULLISH') { ls += 2; reasons.long.push('HTF Bullish'); }
    else if (STATE.htfBias === 'BEARISH') { ss += 2; reasons.short.push('HTF Bearish'); }
    else {
        // Keine Signale bei neutralem HTF Bias
        renderNoSignal(0);
        return;
    }
    document.getElementById('cfHTF').textContent = STATE.htfBias;
    document.getElementById('cfHTF').style.color = STATE.htfBias === 'BULLISH' ? 'var(--long)' : 'var(--short)';

    // 2. FVG (2pts) - Nur signifikante FVGs
    const nbf = STATE.fvgs.find(f => f.type === 'bullish' && f.status === 'open' && price >= f.bottom && price <= f.top * 1.005);
    const nbr = STATE.fvgs.find(f => f.type === 'bearish' && f.status === 'open' && price <= f.top && price >= f.bottom * 0.995);
    if (nbf) { ls += 2; reasons.long.push('In Bull FVG'); }
    if (nbr) { ss += 2; reasons.short.push('In Bear FVG'); }
    document.getElementById('cfFVG').textContent = nbf ? '✓ BULL' : nbr ? '✓ BEAR' : '--';
    document.getElementById('cfFVG').style.color = nbf ? 'var(--long)' : nbr ? 'var(--short)' : 'var(--text-3)';

    // 3. OB (1.5pts)
    const nbo = STATE.orderBlocks.find(ob => ob.type === 'bullish' && price >= ob.low && price <= ob.high * 1.002);
    const nso = STATE.orderBlocks.find(ob => ob.type === 'bearish' && price <= ob.high && price >= ob.low * 0.998);
    if (nbo) { ls += 1.5; reasons.long.push('Bull OB'); }
    if (nso) { ss += 1.5; reasons.short.push('Bear OB'); }
    document.getElementById('cfOB').textContent = nbo ? '✓ BULL' : nso ? '✓ BEAR' : '--';
    document.getElementById('cfOB').style.color = nbo ? 'var(--long)' : nso ? 'var(--short)' : 'var(--text-3)';

    // 4. MSS/BOS (2pts) - Nur frische MSS (letzte 20 Candles)
    const rm = STATE.mssEvents.filter(m => candles.length - m.index < 20);
    const lm = rm[rm.length-1];
    if (lm) {
        if (lm.type === 'MSS_BULL') { ls += 2; reasons.long.push('MSS Bullish'); }
        if (lm.type === 'MSS_BEAR') { ss += 2; reasons.short.push('MSS Bearish'); }
    }
    
    // Trend-Konsistenz: Keine Longs in bearish Trend, keine Shorts in bullish Trend
    if (STATE.currentTrend === 'bullish' && ls < ss) { renderNoSignal(ss); return; }
    if (STATE.currentTrend === 'bearish' && ss < ls) { renderNoSignal(ls); return; }
    
    const tb = STATE.currentTrend === 'bullish' ? 0.5 : STATE.currentTrend === 'bearish' ? -0.5 : 0;
    ls += Math.max(0, tb); ss += Math.max(0, -tb);
    document.getElementById('cfMSS').textContent = lm ? lm.type.replace('_',' ') : STATE.currentTrend.toUpperCase();
    document.getElementById('cfMSS').style.color = (lm && lm.type.includes('BULL')) || STATE.currentTrend === 'bullish' ? 'var(--long)' : (lm && lm.type.includes('BEAR')) || STATE.currentTrend === 'bearish' ? 'var(--short)' : 'var(--text-3)';

    // 5. Wyckoff (2pts) - Nur starke Phasen
    const wk = STATE.wyckoff;
    if (wk.phase === 'accumulation' && ['Spring','Test','SOS'].includes(wk.subPhase) && wk.confidence > 50) { ls += 2; reasons.long.push('WK '+wk.subPhase); }
    if (wk.phase === 'distribution' && ['Upthrust','LPSY','SOW'].includes(wk.subPhase) && wk.confidence > 50) { ss += 2; reasons.short.push('WK '+wk.subPhase); }
    document.getElementById('cfWyckoff').textContent = wk.subPhase || '--';
    document.getElementById('cfWyckoff').style.color = wk.phase === 'accumulation' ? 'var(--long)' : wk.phase === 'distribution' ? 'var(--short)' : 'var(--text-3)';

    // 6. Liq sweep (1.5pts)
    const sweep = detectLiquiditySweep(candles);
    if (sweep === 'bull') { ls += 1.5; reasons.long.push('Liq Sweep'); }
    if (sweep === 'bear') { ss += 1.5; reasons.short.push('Liq Sweep'); }
    document.getElementById('cfLiq').textContent = sweep ? sweep.toUpperCase()+' SWEEP' : '--';
    document.getElementById('cfLiq').style.color = sweep === 'bull' ? 'var(--long)' : sweep === 'bear' ? 'var(--short)' : 'var(--text-3)';

    // 7. Volume (1pt)
    const avgV = candles.slice(-20).reduce((a,c)=>a+c.v,0)/20;
    const lastV = candles[candles.length-1].v, vc = lastV > avgV * 1.3;
    if (vc) { if (candles[candles.length-1].c > candles[candles.length-1].o) { ls += 1; reasons.long.push('Vol ✓'); } else { ss += 1; reasons.short.push('Vol ✓'); }}
    document.getElementById('cfVol').textContent = vc ? `✓ ${(lastV/avgV).toFixed(1)}x` : `${(lastV/avgV).toFixed(1)}x`;
    document.getElementById('cfVol').style.color = vc ? 'var(--long)' : 'var(--text-3)';

    // Decision - ERHÖHTER THRESHOLD auf 7.5 für höhere Qualität
    const dir = ls > ss ? 'long' : 'short', score = dir === 'long' ? ls : ss, rl = dir === 'long' ? reasons.long : reasons.short;
    
    // Mindestens 7.5 Punkte und mindestens 3 Konfluenzen
    if (score >= 7.5 && rl.length >= 3) {
        const entry = price;
        // Größere Stops für Swing-Trading
        const sl = dir === 'long' ? entry - atrVal*2.5 : entry + atrVal*2.5;
        const tp1 = dir === 'long' ? entry + atrVal*5 : entry - atrVal*5;
        const tp2 = dir === 'long' ? entry + atrVal*8 : entry - atrVal*8;
        const rr = Math.abs(tp1 - entry) / Math.abs(entry - sl);
        
        // Mindestens 1:2 R:R
        if (rr < 2) {
            renderNoSignal(score);
            return;
        }
        
        const quality = score >= 9 ? 'A+' : score >= 8 ? 'A' : 'B';
        const sig = { 
            direction: dir, 
            entry, 
            sl, 
            tp1, 
            tp2, 
            rr, 
            quality, 
            score, 
            reasons: rl, 
            time: Date.now(), 
            status: 'active',
            tf: STATE.currentTF,
            atr: atrVal
        };
        STATE.activeSignal = sig;
        STATE.signalCooldown = Date.now() + STATE.COOLDOWN_MS;
        STATE.signalCount++;
        renderActiveSignal(sig); 
        addSignalToHistory(sig);
        showToast(dir, quality, entry, sl, tp1, rl.join(', '));
        if ('Notification' in window && Notification.permission === 'granted') new Notification(`${dir.toUpperCase()} SIGNAL (${quality})`, { body: `Entry: $${entry.toFixed(0)} | SL: $${sl.toFixed(0)} | TP1: $${tp1.toFixed(0)}` });
    } else { renderNoSignal(Math.max(ls, ss)); }
}

function detectLiquiditySweep(candles) {
    if (candles.length < 30) return null;
    const rec = candles.slice(-10), prev = candles.slice(-30, -10);
    if (prev.length < 10) return null;
    const pL = Math.min(...prev.map(c=>c.l)), pH = Math.max(...prev.map(c=>c.h));
    if (rec.some(c => c.l < pL) && rec[rec.length-1].c > pL) return 'bull';
    if (rec.some(c => c.h > pH) && rec[rec.length-1].c < pH) return 'bear';
    return null;
}

// ============================================================
// SIGNAL UI
// ============================================================
function renderActiveSignal(sig) {
    document.getElementById('activeSignalCard').className = `signal-card active-${sig.direction}`;
    document.getElementById('sigDirection').textContent = sig.direction.toUpperCase();
    document.getElementById('sigDirection').style.color = sig.direction === 'long' ? 'var(--long)' : 'var(--short)';
    document.getElementById('sigQuality').textContent = sig.quality;
    document.getElementById('sigQuality').className = `signal-quality ${sig.quality === 'A+' || sig.quality === 'A' ? 'quality-a' : sig.quality === 'B' ? 'quality-b' : 'quality-c'}`;
    document.getElementById('sigEntry').textContent = '$' + sig.entry.toFixed(0);
    document.getElementById('sigSL').textContent = '$' + sig.sl.toFixed(0); document.getElementById('sigSL').style.color = 'var(--short)';
    document.getElementById('sigTP1').textContent = '$' + sig.tp1.toFixed(0); document.getElementById('sigTP1').style.color = 'var(--long)';
    document.getElementById('sigTP2').textContent = '$' + sig.tp2.toFixed(0); document.getElementById('sigTP2').style.color = 'var(--long)';
    document.getElementById('sigRR').textContent = '1:' + sig.rr.toFixed(1); document.getElementById('sigRR').style.color = sig.rr >= 2 ? 'var(--long)' : sig.rr >= 1.5 ? 'var(--warn)' : 'var(--short)';
    document.getElementById('sigConf').textContent = sig.score.toFixed(1) + '/12';
    document.getElementById('sigReason').textContent = sig.reasons.slice(0,3).join(', '); document.getElementById('sigReason').style.color = 'var(--text-1)';
    document.getElementById('signalBadge').textContent = sig.direction.toUpperCase();
    document.getElementById('signalBadge').style.background = sig.direction === 'long' ? 'var(--long-dim)' : 'var(--short-dim)';
    document.getElementById('signalBadge').style.color = sig.direction === 'long' ? 'var(--long)' : 'var(--short)';
    document.getElementById('signalCount').textContent = STATE.signalCount;
    
    // Click handler für aktives Signal
    document.getElementById('activeSignalCard').onclick = () => openSignalModal(sig);
}

function renderNoSignal(score) {
    const card = document.getElementById('activeSignalCard');
    card.className = 'signal-card';
    card.onclick = null;
    document.getElementById('sigDirection').textContent = 'WARTE...'; document.getElementById('sigDirection').style.color = 'var(--text-3)';
    document.getElementById('sigQuality').textContent = score > 0 ? score.toFixed(0)+'/12' : '--'; document.getElementById('sigQuality').className = 'signal-quality quality-none';
    document.getElementById('signalBadge').textContent = 'SCANNING'; document.getElementById('signalBadge').style.background = 'var(--bg-3)'; document.getElementById('signalBadge').style.color = 'var(--text-3)';
}

function updateCooldownBar() { const r = STATE.signalCooldown - Date.now(); document.getElementById('cooldownFill').style.width = Math.max(0, r/STATE.COOLDOWN_MS*100) + '%'; }

function addSignalToHistory(sig) { STATE.signalHistory.unshift(sig); STATE.historyPage = 0; renderSignalHistory(); }

function renderSignalHistory() {
    const el = document.getElementById('signalHistory'); 
    const btn = document.getElementById('loadMoreBtn');
    document.getElementById('histBadge').textContent = STATE.signalHistory.length;
    
    if (!STATE.signalHistory.length) { 
        el.innerHTML = '<div style="text-align:center;color:var(--text-3);padding:12px;font-size:10px;">Noch keine Signale</div>'; 
        btn.style.display = 'none';
        return; 
    }
    
    const start = 0;
    const end = (STATE.historyPage + 1) * STATE.historyPerPage;
    const visible = STATE.signalHistory.slice(start, end);
    
    el.innerHTML = visible.map((sig, idx) => {
        const time = new Date(sig.time).toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'});
        const dc = sig.direction === 'long' ? 'var(--long)' : 'var(--short)';
        let rt = 'OFFEN', rc = 'var(--warn)';
        if (sig.status === 'tp1') { rt = 'TP1 ✓'; rc = 'var(--long)'; }
        else if (sig.status === 'tp2') { rt = 'TP2 ✓'; rc = 'var(--long)'; }
        else if (sig.status === 'sl') { rt = 'SL ✗'; rc = 'var(--short)'; }
        else if (sig.status === 'expired') { rt = 'EXP'; rc = 'var(--text-3)'; }
        return `<div class="history-item" onclick="openSignalModal(STATE.signalHistory[${idx}])">
            <span style="color:${dc};font-weight:700">${sig.direction.toUpperCase()}</span>
            <span style="color:var(--text-2)">$${sig.entry.toFixed(0)} | ${sig.quality}</span>
            <span style="color:${rc};font-weight:600;text-align:right">${rt}</span>
            <span style="color:var(--text-3);text-align:right">${time}</span>
        </div>`;
    }).join('');
    
    // Load more button anzeigen wenn es mehr gibt
    if (end < STATE.signalHistory.length) {
        btn.style.display = 'block';
        btn.textContent = `Mehr laden (${STATE.signalHistory.length - end} verbleibend)`;
        btn.disabled = false;
    } else {
        btn.style.display = 'none';
    }
}

function loadMoreHistory() {
    STATE.historyPage++;
    renderSignalHistory();
}

function openSignalModal(sig) {
    const modal = document.getElementById('signalModal');
    const title = document.getElementById('modalTitle');
    const body = document.getElementById('modalBody');
    
    const dirColor = sig.direction === 'long' ? 'var(--long)' : 'var(--short)';
    const statusText = sig.status === 'active' ? 'AKTIV' : 
                       sig.status === 'tp1' ? 'TP1 ERREICHT' :
                       sig.status === 'tp2' ? 'TP2 ERREICHT' :
                       sig.status === 'sl' ? 'STOP LOSS' :
                       sig.status === 'expired' ? 'ABGELAUFEN' : 'UNBEKANNT';
    
    // Berechne aktuelles P&L wenn aktiv
    let pnlHtml = '';
    if (sig.status === 'active') {
        const currentPnL = sig.direction === 'long' ? 
            ((STATE.price - sig.entry) / (sig.entry - sig.sl)).toFixed(2) :
            ((sig.entry - STATE.price) / (sig.sl - sig.entry)).toFixed(2);
        const pnlColor = parseFloat(currentPnL) >= 0 ? 'pnl-positive' : 'pnl-negative';
        pnlHtml = `<div class="modal-row"><span class="modal-label">Aktuelles R</span><span class="modal-value ${pnlColor}">${currentPnL}R</span></div>`;
    } else {
        const exitPrice = sig.status === 'tp1' ? sig.tp1 : sig.status === 'tp2' ? sig.tp2 : sig.status === 'sl' ? sig.sl : sig.entry;
        const pnl = sig.direction === 'long' ? 
            ((exitPrice - sig.entry) / (sig.entry - sig.sl)).toFixed(2) :
            ((sig.entry - exitPrice) / (sig.sl - sig.entry)).toFixed(2);
        const pnlColor = parseFloat(pnl) >= 0 ? 'pnl-positive' : 'pnl-negative';
        pnlHtml = `<div class="modal-row"><span class="modal-label">Ergebnis</span><span class="modal-value ${pnlColor}">${pnl}R</span></div>`;
    }
    
    title.innerHTML = `<span style="color:${dirColor}">${sig.direction.toUpperCase()} SIGNAL (${sig.quality})</span>`;
    title.innerHTML += `<span style="font-size:9px;color:var(--text-3);margin-left:12px">${statusText}</span>`;
    
    body.innerHTML = `
        <div class="modal-section">
            <div class="modal-section-title">Trade Details</div>
            <div class="modal-row"><span class="modal-label">Entry</span><span class="modal-value">$${sig.entry.toFixed(2)}</span></div>
            <div class="modal-row"><span class="modal-label">Stop Loss</span><span class="modal-value" style="color:var(--short)">$${sig.sl.toFixed(2)}</span></div>
            <div class="modal-row"><span class="modal-label">Take Profit 1</span><span class="modal-value" style="color:var(--long)">$${sig.tp1.toFixed(2)}</span></div>
            <div class="modal-row"><span class="modal-label">Take Profit 2</span><span class="modal-value" style="color:var(--long)">$${sig.tp2.toFixed(2)}</span></div>
            <div class="modal-row"><span class="modal-label">R:R Verhältnis</span><span class="modal-value">1:${sig.rr.toFixed(2)}</span></div>
            ${pnlHtml}
        </div>
        
        <div class="modal-section">
            <div class="modal-section-title">Konfluenz (${sig.score.toFixed(1)} Punkte)</div>
            ${sig.reasons.map(r => `<div class="modal-row"><span class="modal-label">✓</span><span class="modal-value">${r}</span></div>`).join('')}
        </div>
        
        <div class="modal-section">
            <div class="modal-section-title">Metadaten</div>
            <div class="modal-row"><span class="modal-label">Zeitrahmen</span><span class="modal-value">${sig.tf || STATE.currentTF}</span></div>
            <div class="modal-row"><span class="modal-label">Zeit</span><span class="modal-value">${new Date(sig.time).toLocaleString('de-DE')}</span></div>
            <div class="modal-row"><span class="modal-label">ATR</span><span class="modal-value">$${sig.atr ? sig.atr.toFixed(2) : '--'}</span></div>
        </div>
    `;
    
    modal.classList.add('active');
}

function closeModal() {
    document.getElementById('signalModal').classList.remove('active');
}

function trackSignalOutcomes() {
    STATE.signalHistory.forEach(sig => {
        if (sig.status !== 'active') return;
        if (Date.now() - sig.time > 24*60*60*1000) { sig.status = 'expired'; return; }
        if (sig.direction === 'long') { 
            if (STATE.price <= sig.sl) sig.status = 'sl'; 
            else if (STATE.price >= sig.tp2) sig.status = 'tp2'; 
            else if (STATE.price >= sig.tp1) sig.status = 'tp1'; 
        }
        else { 
            if (STATE.price >= sig.sl) sig.status = 'sl'; 
            else if (STATE.price <= sig.tp2) sig.status = 'tp2'; 
            else if (STATE.price <= sig.tp1) sig.status = 'tp1'; 
        }
    });
    const closed = STATE.signalHistory.filter(s => ['tp1','tp2','sl'].includes(s.status));
    if (closed.length) {
        const wr = (closed.filter(s => s.status === 'tp1' || s.status === 'tp2').length / closed.length * 100).toFixed(0);
        document.getElementById('liveWinRate').textContent = wr + '%';
        document.getElementById('liveWinRate').style.color = wr >= 60 ? 'var(--long)' : wr >= 45 ? 'var(--warn)' : 'var(--short)';
    }
    renderSignalHistory();
}

function showToast(dir, quality, entry, sl, tp1, reasons) {
    const c = document.getElementById('toastContainer'), t = document.createElement('div');
    t.className = `toast ${dir === 'long' ? 'long-toast' : 'short-toast'}`;
    t.innerHTML = `<div class="toast-title" style="color:${dir === 'long' ? 'var(--long)' : 'var(--short)'}">${dir.toUpperCase()} SIGNAL (${quality})</div><div class="toast-body">Entry: $${entry.toFixed(0)} | SL: $${sl.toFixed(0)} | TP: $${tp1.toFixed(0)}<br>${reasons}</div><div class="toast-time">${new Date().toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit',second:'2-digit'})}</div>`;
    c.appendChild(t);
    setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), 300); }, 12000);
}

// ============================================================
// CHART WITH ZOOM & PAN
// ============================================================
function getTimeUnit(tf) {
    if (tf.includes('m')) return 'minute';
    if (tf.includes('h') || tf.includes('H')) return 'hour';
    if (tf.includes('d') || tf.includes('D')) return 'day';
    if (tf.includes('w') || tf.includes('W')) return 'week';
    return 'hour';
}

function getTimeFormat(tf) {
    if (tf === '1m' || tf === '3m' || tf === '5m') return { minute: 'HH:mm' };
    if (tf === '15m' || tf === '30m') return { hour: 'HH:mm' };
    if (tf === '1h' || tf === '2h' || tf === '4h') return { day: 'dd.MM', hour: 'dd. HH:mm' };
    return { day: 'dd.MM' };
}

function buildAnnotations() {
    const candles = STATE.tfData[STATE.currentTF];
    if (!candles || !candles.length) return {};
    const annotations = {};
    let aid = 0;

    if (STATE.overlays.fvg) {
        STATE.fvgs.filter(f => f.status !== 'filled').slice(-6).forEach(f => {
            annotations['fvg' + aid++] = {
                type: 'box',
                yMin: f.bottom,
                yMax: f.top,
                xMin: f.time,
                backgroundColor: f.type === 'bullish' ? 'rgba(0,230,118,0.06)' : 'rgba(255,23,68,0.06)',
                borderColor: f.type === 'bullish' ? 'rgba(0,230,118,0.25)' : 'rgba(255,23,68,0.25)',
                borderWidth: 1,
                borderDash: [3, 3],
                label: {
                    display: true,
                    content: f.type === 'bullish' ? 'FVG ↑' : 'FVG ↓',
                    position: 'start',
                    font: { size: 8, family: 'JetBrains Mono' },
                    color: f.type === 'bullish' ? 'rgba(0,230,118,0.6)' : 'rgba(255,23,68,0.6)',
                    backgroundColor: 'transparent'
                }
            };
        });
    }

    if (STATE.overlays.ob) {
        STATE.orderBlocks.slice(-4).forEach(ob => {
            annotations['ob' + aid++] = {
                type: 'box',
                yMin: ob.low,
                yMax: ob.high,
                xMin: ob.time,
                backgroundColor: ob.type === 'bullish' ? 'rgba(68,138,255,0.06)' : 'rgba(255,138,68,0.06)',
                borderColor: ob.type === 'bullish' ? 'rgba(68,138,255,0.3)' : 'rgba(255,138,68,0.3)',
                borderWidth: 1,
                label: {
                    display: true,
                    content: ob.type === 'bullish' ? 'OB ↑' : 'OB ↓',
                    position: 'start',
                    font: { size: 8, family: 'JetBrains Mono' },
                    color: ob.type === 'bullish' ? 'rgba(68,138,255,0.7)' : 'rgba(255,138,68,0.7)',
                    backgroundColor: 'transparent'
                }
            };
        });
    }

    if (STATE.overlays.mss) {
        [...STATE.mssEvents.slice(-6), ...STATE.bosEvents.slice(-6)].forEach(ev => {
            const isMSS = ev.type.startsWith('MSS');
            const isBull = ev.type.includes('BULL');
            annotations['mss' + aid++] = {
                type: 'line',
                yMin: ev.price,
                yMax: ev.price,
                xMin: ev.time,
                borderColor: isMSS ? (isBull ? 'rgba(224,64,251,0.7)' : 'rgba(224,64,251,0.5)') : (isBull ? 'rgba(0,230,118,0.4)' : 'rgba(255,23,68,0.4)'),
                borderWidth: isMSS ? 2 : 1,
                borderDash: isMSS ? [] : [6, 4],
                label: {
                    display: true,
                    content: ev.type.replace('_', ' '),
                    position: 'start',
                    font: { size: 8, family: 'JetBrains Mono', weight: isMSS ? '700' : '400' },
                    color: isMSS ? '#e040fb' : (isBull ? 'rgba(0,230,118,0.7)' : 'rgba(255,23,68,0.7)'),
                    backgroundColor: 'rgba(6,8,10,0.8)',
                    padding: { top: 2, bottom: 2, left: 4, right: 4 }
                }
            };
        });
    }

    if (STATE.overlays.liq) {
        STATE.liquidityLevels.slice(0, 4).forEach(l => {
            annotations['liq' + aid++] = {
                type: 'line',
                yMin: l.price,
                yMax: l.price,
                borderColor: 'rgba(255,193,7,0.35)',
                borderWidth: 1,
                borderDash: [8, 4],
                label: {
                    display: true,
                    content: `${l.type} $${l.price.toFixed(0)}`,
                    position: 'end',
                    font: { size: 8, family: 'JetBrains Mono' },
                    color: 'rgba(255,193,7,0.7)',
                    backgroundColor: 'rgba(6,8,10,0.8)',
                    padding: { top: 2, bottom: 2, left: 4, right: 4 }
                }
            };
        });
    }

    return annotations;
}

function initChart() {
    if (STATE.chart) { STATE.chart.destroy(); STATE.chart = null; }
    const ctx = document.getElementById('mainChart').getContext('2d');
    const candles = STATE.tfData[STATE.currentTF];
    if (!candles || !candles.length) return;

    const closes = candles.map(c => c.c);
    const ema20 = calcEMA(closes, 20), ema50 = calcEMA(closes, 50), ema100 = calcEMA(closes, 100), ema200 = calcEMA(closes, 200);
    const showEma = STATE.overlays.ema;

    const datasets = [];

    if (STATE.chartType === 'candles') {
        datasets.push({
            label: 'BTC',
            data: candles.map(c => ({ x: c.t, o: c.o, h: c.h, l: c.l, c: c.c })),
            type: 'candlestick',
            color: { up: '#00e676', down: '#ff1744', unchanged: '#6b7588' },
            borderColor: { up: '#00e676', down: '#ff1744', unchanged: '#6b7588' },
            order: 0
        });
    } else {
        datasets.push({
            label: 'BTC',
            data: closes.map((c, i) => ({ x: candles[i].t, y: c })),
            type: 'line',
            borderColor: '#e8ecf1',
            borderWidth: 1.5,
            pointRadius: 0,
            fill: false,
            tension: 0,
            order: 0
        });
    }

    if (showEma) {
        datasets.push(
            { label: 'EMA 20', data: ema20.map((v, i) => ({ x: candles[i].t, y: v })), type: 'line', borderColor: 'rgba(0,230,118,0.8)', borderWidth: 1.5, pointRadius: 0, fill: false, order: 1 },
            { label: 'EMA 50', data: ema50.map((v, i) => ({ x: candles[i].t, y: v })), type: 'line', borderColor: 'rgba(255,193,7,0.9)', borderWidth: 2, pointRadius: 0, fill: false, order: 2 },
            { label: 'EMA 100', data: ema100.map((v, i) => ({ x: candles[i].t, y: v })), type: 'line', borderColor: 'rgba(255,23,68,0.7)', borderWidth: 1.5, pointRadius: 0, borderDash: [5,5], fill: false, order: 3 },
            { label: 'EMA 200', data: ema200.map((v, i) => ({ x: candles[i].t, y: v })), type: 'line', borderColor: 'rgba(68,138,255,0.9)', borderWidth: 2, pointRadius: 0, fill: false, order: 4 }
        );
    }

    const timeUnit = getTimeUnit(STATE.currentTF);
    const timeFormats = getTimeFormat(STATE.currentTF);

    STATE.chart = new Chart(ctx, {
        type: STATE.chartType === 'candles' ? 'candlestick' : 'line',
        data: { datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            interaction: { intersect: false, mode: 'index' },
            plugins: {
                legend: {
                    display: showEma,
                    labels: { color: '#a0a8b8', font: { family: 'JetBrains Mono', size: 9 }, usePointStyle: true, pointStyle: 'line', boxWidth: 20 },
                    position: 'top', align: 'end'
                },
                tooltip: {
                    backgroundColor: 'rgba(12,15,19,0.95)', titleColor: '#e8ecf1', bodyColor: '#a0a8b8',
                    borderColor: '#2a3140', borderWidth: 1,
                    titleFont: { family: 'JetBrains Mono', size: 10 }, bodyFont: { family: 'JetBrains Mono', size: 9 }, padding: 8,
                    callbacks: {
                        title: function(context) {
                            const date = new Date(context[0].parsed.x);
                            return date.toLocaleString('de-DE');
                        },
                        label: function(ctx) {
                            if (ctx.dataset.label === 'BTC' && STATE.chartType === 'candles' && ctx.raw && ctx.raw.o !== undefined) {
                                const d = ctx.raw; return `O: $${d.o.toFixed(0)} H: $${d.h.toFixed(0)} L: $${d.l.toFixed(0)} C: $${d.c.toFixed(0)}`;
                            }
                            return `${ctx.dataset.label}: $${ctx.parsed.y?.toLocaleString() || ''}`;
                        }
                    }
                },
                annotation: { annotations: buildAnnotations() },
                zoom: {
                    pan: { enabled: true, mode: 'xy', modifierKey: null },
                    zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'xy', drag: { enabled: false } },
                    limits: { x: { min: 'original', max: 'original' }, y: { min: 'original', max: 'original' } }
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: timeUnit, displayFormats: timeFormats, tooltipFormat: 'dd.MM.yyyy HH:mm' },
                    grid: { color: 'rgba(30,37,48,0.5)' },
                    ticks: { color: '#444e5f', font: { family: 'JetBrains Mono', size: 9 }, maxRotation: 0, autoSkip: true, maxTicksLimit: 8 }
                },
                y: {
                    position: 'right',
                    grid: { color: 'rgba(30,37,48,0.5)' },
                    ticks: { color: '#444e5f', font: { family: 'JetBrains Mono', size: 9 }, callback: v => '$' + v.toLocaleString() }
                }
            }
        }
    });
    
    document.getElementById('mainChart').addEventListener('dblclick', () => {
        if (STATE.chart) STATE.chart.resetZoom();
    });
}

function updateChart() {
    if (!STATE.chart) return;
    const candles = STATE.tfData[STATE.currentTF];
    if (!candles || !candles.length) return;

    const closes = candles.map(c => c.c);

    if (STATE.chartType === 'candles') {
        STATE.chart.data.datasets[0].data = candles.map(c => ({ x: c.t, o: c.o, h: c.h, l: c.l, c: c.c }));
    } else {
        STATE.chart.data.datasets[0].data = closes.map((c, i) => ({ x: candles[i].t, y: c }));
    }

    if (STATE.overlays.ema && STATE.chart.data.datasets.length > 1) {
        const ema20 = calcEMA(closes, 20), ema50 = calcEMA(closes, 50), ema100 = calcEMA(closes, 100), ema200 = calcEMA(closes, 200);
        STATE.chart.data.datasets[1].data = ema20.map((v, i) => ({ x: candles[i].t, y: v }));
        STATE.chart.data.datasets[2].data = ema50.map((v, i) => ({ x: candles[i].t, y: v }));
        STATE.chart.data.datasets[3].data = ema100.map((v, i) => ({ x: candles[i].t, y: v }));
        STATE.chart.data.datasets[4].data = ema200.map((v, i) => ({ x: candles[i].t, y: v }));
    }

    STATE.chart.options.plugins.annotation.annotations = buildAnnotations();
    STATE.chart.update('none');
}

// ============================================================
// BACKTEST
// ============================================================
function runQuickBacktest() {
    const data = STATE.tfData['1h'];
    if (!data || data.length < 200) return;
    let trades = [], eq = 10000, mxEq = 10000, mxDD = 0;
    for (let i = 60; i < data.length - 30; i += 5) {
        const sl = data.slice(Math.max(0,i-60), i), fut = data.slice(i, i+20), p = data[i].c;
        let sig = null;
        for (let j = sl.length-1; j >= sl.length-10 && j >= 2; j--) {
            if (sl[j].l > sl[j-2].h && p >= sl[j-2].h && p <= sl[j].l) { sig = { d: 'l', e: p, s: sl[j-2].h*0.997, t: p*1.01 }; break; }
            if (sl[j].h < sl[j-2].l && p <= sl[j-2].l && p >= sl[j].h) { sig = { d: 's', e: p, s: sl[j-2].l*1.003, t: p*0.99 }; break; }
        }
        if (!sig) continue;
        let win = false;
        for (const c of fut) {
            if (sig.d === 'l') { if (c.l <= sig.s) break; if (c.h >= sig.t) { win = true; break; } }
            else { if (c.h >= sig.s) break; if (c.l <= sig.t) { win = true; break; } }
        }
        const r = eq * 0.01, pnl = win ? r*1.5 : -r;
        eq += pnl; mxEq = Math.max(mxEq, eq); mxDD = Math.max(mxDD, (mxEq-eq)/mxEq);
        trades.push({ win, pnl });
    }
    if (!trades.length) return;
    const w = trades.filter(t=>t.win).length, wr = (w/trades.length*100).toFixed(0);
    const gw = trades.filter(t=>t.win).reduce((a,t)=>a+t.pnl,0), gl = Math.abs(trades.filter(t=>!t.win).reduce((a,t)=>a+t.pnl,0));
    const pf = gl > 0 ? (gw/gl).toFixed(1) : '∞';
    document.getElementById('btWinRate').textContent = wr+'%'; document.getElementById('btWinRate').style.color = wr >= 55 ? 'var(--long)' : wr >= 45 ? 'var(--warn)' : 'var(--short)';
    document.getElementById('btPF').textContent = pf; document.getElementById('btPF').style.color = parseFloat(pf) >= 1.5 ? 'var(--long)' : 'var(--warn)';
    document.getElementById('btRR').textContent = '1:1.5'; document.getElementById('btRR').style.color = 'var(--text-1)';
    document.getElementById('btDD').textContent = (mxDD*100).toFixed(1)+'%'; document.getElementById('btDD').style.color = mxDD < 0.1 ? 'var(--long)' : mxDD < 0.2 ? 'var(--warn)' : 'var(--short)';
}

// ============================================================
// WEBSOCKET
// ============================================================
function connectWS() {
    if (STATE.ws) try { STATE.ws.close(); } catch(e) {}
    const ws = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@trade');
    STATE.ws = ws;
    let lastCU = 0, lastA = 0, tc = 0;

    ws.onopen = () => {
        document.getElementById('wsStatus').style.background = 'var(--long)';
        document.getElementById('wsStatus').style.boxShadow = '0 0 8px var(--long-glow)';
        if (STATE.wsReconnectTimer) { clearTimeout(STATE.wsReconnectTimer); STATE.wsReconnectTimer = null; }
    };

    ws.onmessage = (e) => {
        const d = JSON.parse(e.data);
        STATE.price = parseFloat(d.p);
        tc++;
        document.getElementById('livePrice').textContent = '$' + STATE.price.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
        if (STATE.openPrice24h > 0) {
            const ch = ((STATE.price / STATE.openPrice24h - 1) * 100);
            const el = document.getElementById('priceChange');
            el.textContent = (ch >= 0 ? '+' : '') + ch.toFixed(2) + '%';
            el.className = ch >= 0 ? 'price-change price-up' : 'price-change price-down';
        }
        const tf = STATE.currentTF;
        if (STATE.tfData[tf] && STATE.tfData[tf].length) {
            const last = STATE.tfData[tf][STATE.tfData[tf].length-1];
            last.c = STATE.price;
            if (STATE.price > last.h) last.h = STATE.price;
            if (STATE.price < last.l) last.l = STATE.price;
        }
        const now = Date.now();
        if (now - lastCU > 2000) { updateChart(); lastCU = now; }
        if (now - lastA > 10000) { runAnalysis(); lastA = now; }
        if (tc % 50 === 0) { trackSignalOutcomes(); updateCooldownBar(); }
    };

    ws.onerror = () => { document.getElementById('wsStatus').style.background = 'var(--short)'; document.getElementById('wsStatus').style.boxShadow = '0 0 8px var(--short-glow)'; };
    ws.onclose = () => { document.getElementById('wsStatus').style.background = 'var(--warn)'; document.getElementById('wsStatus').style.boxShadow = '0 0 8px rgba(255,193,7,0.4)'; STATE.wsReconnectTimer = setTimeout(connectWS, 3000); };
}

// ============================================================
// ANALYSIS PIPELINE
// ============================================================
function runAnalysis() {
    const candles = STATE.tfData[STATE.currentTF];
    if (!candles || candles.length < 50) return;
    detectFVGs(candles); detectOrderBlocks(candles);
    detectSwingPoints(candles); detectMSSandBOS(candles);
    detectLiquidityLevels(); analyzeMTFBias(); analyzeWyckoff();
    renderFVGList(); renderLiquidity(); renderMTFBias();
    generateSignals();
}

// ============================================================
// EVENT HANDLERS
// ============================================================
document.querySelectorAll('.tf-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
        document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        STATE.currentTF = btn.dataset.tf;
        if (!STATE.tfData[STATE.currentTF]) {
            const data = await fetchCandles(STATE.currentTF, 500);
            if (data) STATE.tfData[STATE.currentTF] = data;
        }
        initChart();
        runAnalysis();
    });
});

document.getElementById('btnLine').addEventListener('click', () => { STATE.chartType = 'line'; document.getElementById('btnLine').classList.add('active'); document.getElementById('btnCandles').classList.remove('active'); initChart(); });
document.getElementById('btnCandles').addEventListener('click', () => { STATE.chartType = 'candles'; document.getElementById('btnCandles').classList.add('active'); document.getElementById('btnLine').classList.remove('active'); initChart(); });

document.querySelectorAll('.toggle-chip').forEach(chip => {
    chip.addEventListener('click', () => {
        const key = chip.dataset.overlay;
        STATE.overlays[key] = !STATE.overlays[key];
        chip.classList.toggle('on', STATE.overlays[key]);
        initChart();
    });
});

document.getElementById('signalModal').addEventListener('click', (e) => {
    if (e.target.id === 'signalModal') closeModal();
});

async function refreshData() {
    for (const tf of Object.keys(STATE.tfData)) {
        const data = await fetchCandles(tf, 500);
        if (data) STATE.tfData[tf] = data;
    }
    runAnalysis(); runQuickBacktest();
}

// ============================================================
// INIT
// ============================================================
async function init() {
    const ld = document.getElementById('loadingStatus');
    try {
        ld.textContent = 'Lade Multi-Timeframe Daten...';
        await loadAllTimeframes();
        ld.textContent = 'Analysiere Marktstruktur...';
        runAnalysis();
        ld.textContent = 'Initialisiere Chart...';
        initChart();
        ld.textContent = 'Berechne Backtest...';
        runQuickBacktest();
        ld.textContent = 'Verbinde Live-Feed...';
        connectWS();
        if ('Notification' in window && Notification.permission === 'default') Notification.requestPermission();
        setTimeout(() => document.getElementById('loadingOverlay').classList.add('hidden'), 800);
        setInterval(refreshData, 5 * 60 * 1000);
    } catch (err) { ld.textContent = 'Fehler: ' + err.message; console.error(err); }
}

window.addEventListener('load', init);
</script>
</body>
</html>
