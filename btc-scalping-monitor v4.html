<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC Scalping Monitor Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Oxanium:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.1/dist/chartjs-chart-financial.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>
    <style>
        :root {
            --bg-0: #06080a;
            --bg-1: #0c0f13;
            --bg-2: #12161c;
            --bg-3: #1a1f28;
            --border: #1e2530;
            --border-bright: #2a3140;
            --text-0: #e8ecf1;
            --text-1: #a0a8b8;
            --text-2: #6b7588;
            --text-3: #444e5f;
            --accent: #f7931a;
            --accent-dim: rgba(247, 147, 26, 0.15);
            --long: #00e676;
            --long-dim: rgba(0, 230, 118, 0.12);
            --long-glow: rgba(0, 230, 118, 0.4);
            --short: #ff1744;
            --short-dim: rgba(255, 23, 68, 0.12);
            --short-glow: rgba(255, 23, 68, 0.4);
            --warn: #ffc107;
            --info: #448aff;
            --volume-long: rgba(0, 230, 118, 0.3);
            --volume-short: rgba(255, 23, 68, 0.3);
            --risky: #ff6d00;
            --neutral: #ffd600;
            --safe: #00c853;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-0);
            color: var(--text-0);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
        }

        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: var(--bg-1); }
        ::-webkit-scrollbar-thumb { background: var(--border-bright); border-radius: 2px; }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: var(--bg-1);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            font-family: 'Oxanium', sans-serif;
            font-size: 15px;
            font-weight: 700;
            color: var(--accent);
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--long);
            box-shadow: 0 0 8px var(--long-glow);
            animation: pulse-dot 2s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .header-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .lang-switch {
            display: flex;
            gap: 2px;
            background: var(--bg-2);
            padding: 2px;
            border-radius: 4px;
            border: 1px solid var(--border);
        }

        .lang-btn {
            background: transparent;
            border: none;
            color: var(--text-2);
            padding: 4px 8px;
            cursor: pointer;
            font-family: 'Oxanium', sans-serif;
            font-size: 10px;
            font-weight: 600;
            border-radius: 2px;
            transition: all 0.2s;
        }

        .lang-btn.active {
            background: var(--accent);
            color: #000;
        }

        .header-price {
            display: flex;
            align-items: baseline;
            gap: 12px;
        }

        .price-main {
            font-family: 'Oxanium', sans-serif;
            font-size: 22px;
            font-weight: 700;
            color: var(--text-0);
            letter-spacing: 1px;
        }

        .price-change {
            font-size: 12px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 3px;
        }

        .price-up { background: var(--long-dim); color: var(--long); }
        .price-down { background: var(--short-dim); color: var(--short); }

        .header-stats {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .stat-item { text-align: right; }
        .stat-label {
            font-size: 8px;
            color: var(--text-3);
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }
        .stat-value {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-1);
        }

        .main {
            display: grid;
            grid-template-columns: 290px 1fr 280px;
            gap: 1px;
            height: calc(100vh - 44px);
            background: var(--border);
        }

        .col {
            background: var(--bg-0);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .col-content {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .panel {
            border-bottom: 1px solid var(--border);
            background: var(--bg-0);
            transition: all 0.3s;
        }

        .panel.dragging {
            opacity: 0.5;
            border: 1px dashed var(--accent);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            cursor: move;
            background: var(--bg-1);
            border-bottom: 1px solid transparent;
            transition: all 0.2s;
            user-select: none;
        }

        .panel-header:hover {
            background: var(--bg-2);
            border-bottom-color: var(--border-bright);
        }

        .panel.minimized .panel-header {
            border-bottom-color: transparent;
        }

        .panel-title {
            font-family: 'Oxanium', sans-serif;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .panel-controls {
            display: flex;
            gap: 6px;
        }

        .panel-btn {
            background: transparent;
            border: none;
            color: var(--text-3);
            cursor: pointer;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px;
            font-size: 10px;
            transition: all 0.2s;
        }

        .panel-btn:hover {
            background: var(--bg-3);
            color: var(--text-0);
        }

        .panel-content {
            padding: 10px;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s;
            max-height: 1000px;
        }

        .panel.minimized .panel-content {
            max-height: 0;
            padding: 0 10px;
        }

        .panel-placeholder {
            border: 2px dashed var(--accent);
            background: var(--accent-dim);
            margin: 4px;
            border-radius: 4px;
            height: 40px;
        }

        .badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            padding: 2px 6px;
            border-radius: 2px;
            font-weight: 600;
        }

        .badge-live { background: var(--long-dim); color: var(--long); }
        .badge-warn { background: rgba(255,193,7,0.15); color: var(--warn); }
        .badge-short { background: var(--short-dim); color: var(--short); }
        .badge-risky { background: rgba(255,109,0,0.2); color: var(--risky); border: 1px solid var(--risky); }
        .badge-neutral { background: rgba(255,214,0,0.2); color: var(--neutral); border: 1px solid var(--neutral); }
        .badge-safe { background: rgba(0,200,83,0.2); color: var(--safe); border: 1px solid var(--safe); }

        .signal-card {
            background: var(--bg-2);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 6px;
            transition: all 0.3s;
            cursor: pointer;
        }

        .signal-card.active-long {
            border-color: var(--long);
            box-shadow: 0 0 15px var(--long-dim);
        }

        .signal-card.active-short {
            border-color: var(--short);
            box-shadow: 0 0 15px var(--short-dim);
        }

        .signal-card.risky { border-left: 3px solid var(--risky); }
        .signal-card.neutral { border-left: 3px solid var(--neutral); }
        .signal-card.safe { border-left: 3px solid var(--safe); }

        .signal-card:hover {
            border-color: var(--border-bright);
            transform: translateX(2px);
        }

        .signal-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .signal-direction {
            font-family: 'Oxanium', sans-serif;
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .signal-quality {
            font-size: 9px;
            font-weight: 700;
            padding: 2px 8px;
            border-radius: 2px;
            letter-spacing: 1px;
        }

        .quality-a { background: var(--long); color: #000; }
        .quality-b { background: var(--warn); color: #000; }
        .quality-c { background: var(--text-3); color: var(--text-1); }
        .quality-risky { background: var(--risky); color: #000; }
        .quality-neutral { background: var(--neutral); color: #000; }
        .quality-safe { background: var(--safe); color: #000; }
        .quality-none { background: var(--bg-3); color: var(--text-3); }

        .signal-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            font-size: 10px;
        }

        .signal-row .label { color: var(--text-2); }
        .signal-row .value { font-weight: 500; color: var(--text-0); }
        .signal-row .value.long { color: var(--long); }
        .signal-row .value.short { color: var(--short); }
        .signal-row .value.warn { color: var(--warn); }
        .signal-row .value.dim { color: var(--text-2); }
        .signal-row .value.risky { color: var(--risky); }
        .signal-row .value.neutral { color: var(--neutral); }
        .signal-row .value.safe { color: var(--safe); }

        .warning-text {
            color: var(--warn);
            font-size: 9px;
            margin-top: 4px;
            font-style: italic;
        }

        .chart-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .chart-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: var(--bg-1);
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
            gap: 6px;
        }

        .toolbar-left {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar-right {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .tf-group {
            display: flex;
            gap: 2px;
        }

        .tf-btn {
            background: var(--bg-2);
            border: 1px solid var(--border);
            color: var(--text-2);
            padding: 4px 8px;
            cursor: pointer;
            font-family: 'Oxanium', sans-serif;
            font-size: 10px;
            font-weight: 600;
            border-radius: 2px;
            transition: all 0.2s;
        }

        .tf-btn:hover { border-color: var(--text-3); color: var(--text-1); }
        .tf-btn.active { background: var(--accent); color: #000; border-color: var(--accent); }

        .chart-toggles {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toggle-chip {
            font-size: 9px;
            color: var(--text-2);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            user-select: none;
            padding: 3px 6px;
            border-radius: 2px;
            border: 1px solid transparent;
            transition: all 0.2s;
        }

        .toggle-chip:hover { border-color: var(--border-bright); }
        .toggle-chip.on { color: var(--text-0); border-color: var(--border-bright); background: var(--bg-3); }

        .toggle-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .chart-type-group {
            display: flex;
            gap: 2px;
        }

        .chart-type-btn {
            background: var(--bg-2);
            border: 1px solid var(--border);
            color: var(--text-2);
            padding: 4px 10px;
            cursor: pointer;
            font-family: 'Oxanium', sans-serif;
            font-size: 9px;
            font-weight: 600;
            border-radius: 2px;
            transition: all 0.2s;
        }

        .chart-type-btn:hover { border-color: var(--text-3); color: var(--text-1); }
        .chart-type-btn.active { background: var(--bg-3); color: var(--text-0); border-color: var(--text-2); }

        .chart-wrap {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            background: var(--bg-0);
            position: relative;
        }

        .chart-container-main {
            flex: 1;
            position: relative;
            min-height: 0;
            cursor: crosshair;
        }

        .chart-container-rsi {
            height: 80px;
            position: relative;
            border-top: 1px solid var(--border);
            background: var(--bg-0);
            cursor: crosshair;
            display: none;
        }

        .chart-container-volume {
            height: 80px;
            position: relative;
            border-top: 1px solid var(--border);
            background: var(--bg-0);
            cursor: crosshair;
        }

        .chart-wrap canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .chart-hint {
            position: absolute;
            bottom: 4px;
            right: 8px;
            font-size: 8px;
            color: var(--text-3);
            pointer-events: none;
            z-index: 10;
            background: rgba(6,8,10,0.8);
            padding: 4px 8px;
            border-radius: 3px;
            border: 1px solid var(--border);
        }

        .fvg-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: var(--bg-2);
            border-radius: 3px;
            margin-bottom: 3px;
            font-size: 10px;
            border-left: 3px solid transparent;
        }

        .fvg-item.bull { border-left-color: var(--long); }
        .fvg-item.bear { border-left-color: var(--short); }

        .fvg-tag {
            font-size: 8px;
            font-weight: 600;
            padding: 1px 5px;
            border-radius: 2px;
            letter-spacing: 0.5px;
        }

        .tag-open { background: var(--long-dim); color: var(--long); }
        .tag-partial { background: rgba(255,193,7,0.15); color: var(--warn); }

        .wyckoff-bar {
            display: flex;
            gap: 3px;
            margin: 6px 0;
        }

        .wk-phase {
            flex: 1;
            height: 4px;
            background: var(--bg-3);
            border-radius: 2px;
            overflow: hidden;
        }

        .wk-phase.active {
            background: var(--accent);
            box-shadow: 0 0 8px var(--accent-dim);
        }

        .wk-phase.current { animation: wk-pulse 1.5s infinite; }

        @keyframes wk-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .liq-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            font-size: 10px;
        }

        .liq-bar-wrap {
            flex: 1;
            height: 4px;
            background: var(--bg-3);
            border-radius: 2px;
            overflow: hidden;
        }

        .liq-bar-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.5s;
        }

        .liq-bar-fill.above { background: linear-gradient(90deg, var(--short), #ff6e40); }
        .liq-bar-fill.below { background: linear-gradient(90deg, var(--long), #69f0ae); }

        .fib-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            font-size: 9px;
            border-bottom: 1px solid var(--border);
        }

        .fib-row:last-child { border-bottom: none; }
        .fib-level { color: var(--text-2); }
        .fib-price { font-weight: 600; font-family: 'JetBrains Mono', monospace; }

        .session-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .session-asian { background: #ffd700; box-shadow: 0 0 4px #ffd700; }
        .session-london { background: #00bcd4; box-shadow: 0 0 4px #00bcd4; }
        .session-ny { background: #ff5722; box-shadow: 0 0 4px #ff5722; }

        .funding-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 6px;
        }

        .funding-cell {
            background: var(--bg-2);
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            border: 1px solid var(--border);
        }

        .funding-label {
            font-size: 8px;
            color: var(--text-3);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        .funding-value {
            font-size: 14px;
            font-weight: 700;
            font-family: 'Oxanium', sans-serif;
        }

        .oi-bar {
            width: 100%;
            height: 4px;
            background: var(--bg-3);
            border-radius: 2px;
            margin-top: 6px;
            overflow: hidden;
        }

        .oi-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--info), var(--accent));
            transition: width 0.5s;
        }

        .history-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 8px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 8px;
        }

        .history-tab {
            background: var(--bg-2);
            border: 1px solid var(--border);
            color: var(--text-2);
            padding: 4px 10px;
            cursor: pointer;
            font-size: 9px;
            font-weight: 600;
            border-radius: 2px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .history-tab:hover { border-color: var(--text-3); color: var(--text-1); }
        .history-tab.active { background: var(--accent); color: #000; border-color: var(--accent); }

        .history-filters {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .filter-chip {
            background: var(--bg-2);
            border: 1px solid var(--border);
            color: var(--text-3);
            padding: 2px 6px;
            cursor: pointer;
            font-size: 8px;
            border-radius: 2px;
            transition: all 0.2s;
        }

        .filter-chip:hover { border-color: var(--text-2); color: var(--text-1); }
        .filter-chip.active { background: var(--bg-3); color: var(--text-0); border-color: var(--text-2); }

        .history-item {
            display: grid;
            grid-template-columns: 50px 1fr 60px 50px;
            gap: 6px;
            padding: 5px 8px;
            background: var(--bg-2);
            border-radius: 3px;
            margin-bottom: 3px;
            font-size: 9px;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .history-item:hover {
            background: var(--bg-3);
            border-color: var(--border-bright);
        }

        .history-item.risky { border-left: 2px solid var(--risky); }
        .history-item.neutral { border-left: 2px solid var(--neutral); }
        .history-item.safe { border-left: 2px solid var(--safe); }

        .mtf-row {
            display: grid;
            grid-template-columns: 40px 1fr 60px;
            gap: 8px;
            padding: 4px 0;
            align-items: center;
            font-size: 10px;
            border-bottom: 1px solid var(--border);
        }

        .mtf-tf { font-weight: 600; color: var(--text-2); }

        .mtf-bar-wrap {
            height: 6px;
            background: var(--bg-3);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .mtf-bar-center {
            position: absolute;
            left: 50%;
            top: 0;
            width: 1px;
            height: 100%;
            background: var(--text-3);
        }

        .mtf-bar-fill {
            height: 100%;
            border-radius: 3px;
            transition: all 0.5s;
            position: absolute;
            top: 0;
        }

        .alert-toast {
            position: fixed;
            top: 52px;
            right: 12px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 6px;
            pointer-events: none;
        }

        .toast {
            background: var(--bg-1);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 10px 14px;
            min-width: 300px;
            pointer-events: auto;
            animation: slide-in 0.3s ease-out;
            border-left: 3px solid;
        }

        .toast.long-toast { border-left-color: var(--long); }
        .toast.short-toast { border-left-color: var(--short); }
        .toast.info-toast { border-left-color: var(--info); }
        .toast.fvg-toast { border-left-color: var(--accent); }
        .toast.warn-toast { border-left-color: var(--warn); }

        @keyframes slide-in {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .toast-title {
            font-family: 'Oxanium', sans-serif;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 3px;
        }

        .toast-body { font-size: 10px; color: var(--text-2); line-height: 1.4; }
        .toast-time { font-size: 8px; color: var(--text-3); margin-top: 4px; }

        .bt-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }

        .bt-cell {
            background: var(--bg-2);
            padding: 6px;
            border-radius: 3px;
            text-align: center;
        }

        .bt-cell .bt-label {
            font-size: 7px;
            color: var(--text-3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .bt-cell .bt-value {
            font-size: 13px;
            font-weight: 600;
            margin-top: 2px;
        }

        .cooldown-bar {
            width: 100%;
            height: 3px;
            background: var(--bg-3);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 6px;
        }

        .cooldown-fill {
            height: 100%;
            background: var(--accent);
            transition: width 1s linear;
        }

        .loading-overlay {
            position: fixed;
            inset: 0;
            background: var(--bg-0);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s;
        }

        .loading-overlay.hidden { opacity: 0; pointer-events: none; }

        .loading-text {
            font-family: 'Oxanium', sans-serif;
            font-size: 14px;
            color: var(--accent);
            letter-spacing: 3px;
            margin-top: 16px;
        }

        .loading-sub { font-size: 10px; color: var(--text-3); margin-top: 6px; }

        .loading-spinner {
            width: 40px; height: 40px;
            border: 2px solid var(--border);
            border-top: 2px solid var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(6,8,10,0.85);
            backdrop-filter: blur(4px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-overlay.active { display: flex; }

        .modal-content {
            background: var(--bg-1);
            border: 1px solid var(--border);
            border-radius: 6px;
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-family: 'Oxanium', sans-serif;
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-2);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            transition: all 0.2s;
        }

        .modal-close:hover {
            background: var(--bg-2);
            color: var(--text-0);
        }

        .modal-body {
            padding: 20px;
        }

        .modal-section {
            margin-bottom: 16px;
        }

        .modal-section-title {
            font-size: 9px;
            color: var(--text-3);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 8px;
        }

        .modal-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid var(--border);
            font-size: 11px;
        }

        .modal-row:last-child { border-bottom: none; }

        .modal-label { color: var(--text-2); }
        .modal-value { font-weight: 600; }

        .load-more-btn {
            width: 100%;
            padding: 8px;
            background: var(--bg-2);
            border: 1px solid var(--border);
            color: var(--text-2);
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            cursor: pointer;
            border-radius: 3px;
            margin-top: 8px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .load-more-btn:hover {
            background: var(--bg-3);
            color: var(--text-1);
            border-color: var(--border-bright);
        }

        .load-more-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pnl-positive { color: var(--long); }
        .pnl-negative { color: var(--short); }
        
        .volume-label {
            position: absolute;
            top: 6px;
            left: 10px;
            font-size: 8px;
            color: var(--text-3);
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 5;
            pointer-events: none;
        }

        .candle-pattern-tag {
            display: inline-block;
            font-size: 8px;
            padding: 2px 6px;
            border-radius: 2px;
            margin-right: 4px;
            font-weight: 600;
        }

        .pattern-bull { background: rgba(0,230,118,0.2); color: var(--long); border: 1px solid var(--long); }
        .pattern-bear { background: rgba(255,23,68,0.2); color: var(--short); border: 1px solid var(--short); }

        .divergence-tag {
            display: inline-block;
            font-size: 8px;
            padding: 2px 6px;
            border-radius: 2px;
            margin-right: 4px;
            font-weight: 600;
            background: rgba(156, 39, 176, 0.2);
            color: #ce93d8;
            border: 1px solid #9c27b0;
        }

        @media (max-width: 1200px) {
            .main { grid-template-columns: 260px 1fr 240px; }
        }
        
        @media (max-width: 900px) {
            .main { grid-template-columns: 1fr; grid-template-rows: auto 1fr auto; }
            .col { max-height: 50vh; }
        }
    </style>
</head>
<body>

<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div class="loading-text" data-i18n="loading_title">INITIALISIERUNG</div>
    <div class="loading-sub" id="loadingStatus" data-i18n="loading_market">Lade Marktdaten...</div>
</div>

<div class="alert-toast" id="toastContainer"></div>

<div class="modal-overlay" id="signalModal">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="modalTitle">Signal Details</div>
            <button class="modal-close" onclick="closeModal()">×</button>
        </div>
        <div class="modal-body" id="modalBody"></div>
    </div>
</div>

<div class="header">
    <div class="logo">
        <div class="logo-dot" id="wsStatus"></div>
        <span data-i18n="app_title">BTC SCALPING MONITOR</span>
    </div>
    
    <div class="header-controls">
        <div class="lang-switch">
            <button class="lang-btn active" onclick="setLanguage('de')" id="btnDe">DE</button>
            <button class="lang-btn" onclick="setLanguage('en')" id="btnEn">EN</button>
        </div>
    </div>
    
    <div class="header-price">
        <span class="price-main" id="livePrice">--</span>
        <span class="price-change price-up" id="priceChange">0.00%</span>
    </div>
    
    <div class="header-stats">
        <div class="stat-item">
            <div class="stat-label" data-i18n="header_funding">Funding</div>
            <div class="stat-value" id="headerFunding" style="color:var(--text-2)">--</div>
        </div>
        <div class="stat-item">
            <div class="stat-label" data-i18n="header_oi">Open Interest</div>
            <div class="stat-value" id="headerOI" style="color:var(--text-2)">--</div>
        </div>
        <div class="stat-item">
            <div class="stat-label" data-i18n="header_session">Session</div>
            <div class="stat-value" id="headerSession" style="color:var(--text-2)">--</div>
        </div>
        <div class="stat-item">
            <div class="stat-label" data-i18n="header_bias">HTF Bias</div>
            <div class="stat-value" id="htfBias" style="color:var(--text-2)">--</div>
        </div>
    </div>
</div>

<div class="main">
    <!-- LEFT COLUMN -->
    <div class="col" id="leftCol">
        <div class="col-content" id="leftColContent"></div>
    </div>

    <!-- CENTER: CHART -->
    <div class="col">
        <div class="chart-area">
            <div class="chart-toolbar">
                <div class="toolbar-left">
                    <div class="tf-group">
                        <button class="tf-btn" data-tf="1m">1m</button>
                        <button class="tf-btn" data-tf="3m">3m</button>
                        <button class="tf-btn" data-tf="5m">5m</button>
                        <button class="tf-btn" data-tf="15m">15m</button>
                        <button class="tf-btn" data-tf="30m">30m</button>
                        <button class="tf-btn" data-tf="1h">1h</button>
                        <button class="tf-btn" data-tf="2h">2h</button>
                        <button class="tf-btn active" data-tf="4h">4h</button>
                    </div>
                    <div class="chart-type-group">
                        <button class="chart-type-btn" id="btnLine" data-i18n="chart_line">Line</button>
                        <button class="chart-type-btn active" id="btnCandles" data-i18n="chart_candles">Candles</button>
                    </div>
                </div>
                <div class="toolbar-right">
                    <div class="chart-toggles">
                        <div class="toggle-chip on" data-overlay="ema">
                            <div class="toggle-dot" style="background:var(--long)"></div>EMA
                        </div>
                        <div class="toggle-chip on" data-overlay="fvg">
                            <div class="toggle-dot" style="background:var(--accent)"></div>FVG
                        </div>
                        <div class="toggle-chip on" data-overlay="fib">
                            <div class="toggle-dot" style="background:#9c27b0"></div>FIB
                        </div>
                        <div class="toggle-chip on" data-overlay="session">
                            <div class="toggle-dot" style="background:var(--info)"></div>SESSION
                        </div>
                        <div class="toggle-chip" data-overlay="ob">
                            <div class="toggle-dot" style="background:var(--info)"></div>OB
                        </div>
                        <div class="toggle-chip" data-overlay="mss">
                            <div class="toggle-dot" style="background:#e040fb"></div>MSS
                        </div>
                        <div class="toggle-chip" data-overlay="liq">
                            <div class="toggle-dot" style="background:var(--warn)"></div>LIQ
                        </div>
                        <div class="toggle-chip" data-overlay="rsi">
                            <div class="toggle-dot" style="background:#00bcd4"></div>RSI
                        </div>
                    </div>
                </div>
            </div>
            <div class="chart-wrap">
                <div class="chart-container-main">
                    <canvas id="mainChart"></canvas>
                </div>
                <div class="chart-container-rsi" id="rsiContainer">
                    <div class="volume-label">RSI / StochRSI</div>
                    <canvas id="rsiChart"></canvas>
                </div>
                <div class="chart-container-volume">
                    <div class="volume-label" data-i18n="volume">Volumen</div>
                    <canvas id="volumeChart"></canvas>
                </div>
                <div class="chart-hint" data-i18n="chart_hint">Drag: Pan | Wheel: Zoom | DblClick: Reset</div>
            </div>
        </div>
    </div>

    <!-- RIGHT COLUMN -->
    <div class="col" id="rightCol">
        <div class="col-content" id="rightColContent"></div>
    </div>
</div>

<script>
// ============================================================
// I18N TRANSLATIONS
// ============================================================
const TRANSLATIONS = {
    de: {
        loading_title: "INITIALISIERUNG",
        loading_market: "Lade Marktdaten...",
        app_title: "BTC SCALPING MONITOR",
        header_funding: "Funding",
        header_oi: "Open Interest",
        header_session: "Session",
        header_bias: "HTF Bias",
        chart_line: "Linie",
        chart_candles: "Kerzen",
        volume: "Volumen",
        chart_hint: "Drag: Bewegen | Mausrad: Zoom | Doppelklick: Reset",
        panel_mtf: "Multi-Timeframe Bias",
        panel_market: "Marktdaten",
        panel_session: "Session Highlight",
        panel_fib: "Fibonacci Retracement",
        panel_wyckoff: "Wyckoff Phase",
        panel_fvg: "Fair Value Gaps",
        panel_signal: "Aktives Signal",
        panel_confluence: "Konfluenz Check",
        panel_structure: "Marktstruktur",
        panel_liq: "Liquiditäts-Cluster",
        panel_patterns: "Candle Patterns",
        panel_history: "Signal-Historie",
        panel_stats: "Session Stats",
        panel_rsi: "RSI Analyse",
        signal_waiting: "WARTE...",
        signal_scanning: "SCANNING",
        signal_no_signal: "KEIN SIGNAL",
        status_active: "AKTIV",
        status_tp1: "TP1 ERREICHT",
        status_tp2: "TP2 ERREICHT",
        status_sl: "STOP LOSS",
        status_expired: "ABGELAUFEN",
        category_risky: "RISKY",
        category_neutral: "NEUTRAL",
        category_safe: "SAFE",
        tab_active: "AKTIV",
        tab_closed: "ABGESCHLOSSEN",
        filter_all: "Alle",
        filter_long: "Long",
        filter_short: "Short",
        filter_risky: "Risky",
        filter_safe: "Safe"
    },
    en: {
        loading_title: "INITIALIZING",
        loading_market: "Loading market data...",
        app_title: "BTC SCALPING MONITOR",
        header_funding: "Funding",
        header_oi: "Open Interest",
        header_session: "Session",
        header_bias: "HTF Bias",
        chart_line: "Line",
        chart_candles: "Candles",
        volume: "Volume",
        chart_hint: "Drag: Pan | Wheel: Zoom | DblClick: Reset",
        panel_mtf: "Multi-Timeframe Bias",
        panel_market: "Market Data",
        panel_session: "Session Highlight",
        panel_fib: "Fibonacci Retracement",
        panel_wyckoff: "Wyckoff Phase",
        panel_fvg: "Fair Value Gaps",
        panel_signal: "Active Signal",
        panel_confluence: "Confluence Check",
        panel_structure: "Market Structure",
        panel_liq: "Liquidity Clusters",
        panel_patterns: "Candle Patterns",
        panel_history: "Signal History",
        panel_stats: "Session Stats",
        panel_rsi: "RSI Analysis",
        signal_waiting: "WAITING...",
        signal_scanning: "SCANNING",
        signal_no_signal: "NO SIGNAL",
        status_active: "ACTIVE",
        status_tp1: "TP1 HIT",
        status_tp2: "TP2 HIT",
        status_sl: "STOP LOSS",
        status_expired: "EXPIRED",
        category_risky: "RISKY",
        category_neutral: "NEUTRAL",
        category_safe: "SAFE",
        tab_active: "ACTIVE",
        tab_closed: "CLOSED",
        filter_all: "All",
        filter_long: "Long",
        filter_short: "Short",
        filter_risky: "Risky",
        filter_safe: "Safe"
    }
};

let CURRENT_LANG = localStorage.getItem('btc_monitor_lang') || 'de';

function setLanguage(lang) {
    CURRENT_LANG = lang;
    localStorage.setItem('btc_monitor_lang', lang);
    
    document.getElementById('btnDe').classList.toggle('active', lang === 'de');
    document.getElementById('btnEn').classList.toggle('active', lang === 'en');
    
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (TRANSLATIONS[lang][key]) {
            el.textContent = TRANSLATIONS[lang][key];
        }
    });
    
    // Update panel titles without re-rendering
    document.querySelectorAll('.panel').forEach(panel => {
        const id = panel.dataset.panelId;
        if (id && PANEL_DEFINITIONS[id]) {
            const titleEl = panel.querySelector('.panel-title span:first-child');
            if (titleEl) titleEl.textContent = t(PANEL_DEFINITIONS[id].title);
        }
    });
    
    updateAllUI();
}

function t(key) {
    return TRANSLATIONS[CURRENT_LANG][key] || key;
}

// Safe element updater
function safeSetText(id, text, color) {
    const el = document.getElementById(id);
    if (el) {
        el.textContent = text;
        if (color) el.style.color = color;
    }
}

// ============================================================
// STATE
// ============================================================
const STATE = {
    price: 0,
    openPrice24h: 0,
    ws: null,
    wsReconnectTimer: null,
    chart: null,
    volumeChart: null,
    rsiChart: null,
    currentTF: '4h',
    chartType: 'candles',
    chartState: null,

    overlays: { ema: true, fvg: true, fib: true, session: true, ob: false, mss: false, liq: false, rsi: false },

    tfData: {},
    tfBias: {},

    fvgs: [],
    orderBlocks: [],
    swingPoints: [],
    liquidityLevels: [],
    mssEvents: [],
    bosEvents: [],
    currentTrend: 'neutral',
    
    wyckoff: { 
        htf: { phase: 'none', subPhase: '', confidence: 0 },
        ltf: { phase: 'none', subPhase: '', confidence: 0 },
        combined: 'neutral'
    },

    fibLevels: { high: 0, low: 0, levels: {} },
    currentSession: { name: 'none', start: 0, end: 0, high: 0, low: 0 },
    
    funding: { rate: 0, nextFunding: 0, countdown: '' },
    openInterest: { value: 0, change24h: 0, max24h: 0 },

    activeSignal: null,
    signalHistory: [],
    signalCooldown: 0,
    COOLDOWN_MS: 15 * 60 * 1000,
    signalCount: { risky: 0, neutral: 0, safe: 0 },
    currentPattern: null,
    
    rsiData: [],
    stochRsiData: { k: [], d: [] },
    divergences: [],
    
    historyTab: 'active',
    historyFilter: 'all',
    
    panelOrder: {
        left: ['mtf', 'market', 'session', 'fib', 'wyckoff', 'fvg', 'rsi'],
        right: ['signal', 'confluence', 'structure', 'liq', 'patterns', 'history', 'stats']
    },
    minimizedPanels: new Set(),
    panelsInitialized: false
};

const FVG_THRESHOLDS = {
    '1m': 0.001, '3m': 0.0015, '5m': 0.002, '15m': 0.003,
    '30m': 0.004, '1h': 0.005, '2h': 0.006, '4h': 0.008
};

// ============================================================
// PANEL MANAGEMENT & DRAG DROP
// ============================================================
const PANEL_DEFINITIONS = {
    mtf: { title: 'panel_mtf', badge: 'LIVE', content: renderMTFPanel },
    market: { title: 'panel_market', badge: 'FUTURES', content: renderMarketPanel },
    session: { title: 'panel_session', badge: 'UTC', content: renderSessionPanel },
    fib: { title: 'panel_fib', badge: 'AUTO', content: renderFibPanel },
    wyckoff: { title: 'panel_wyckoff', badge: 'MTF', content: renderWyckoffPanel },
    fvg: { title: 'panel_fvg', badge: null, content: renderFVGPanel },
    rsi: { title: 'panel_rsi', badge: 'LIVE', content: renderRSIPanel },
    signal: { title: 'panel_signal', badge: null, content: renderSignalPanel },
    confluence: { title: 'panel_confluence', badge: null, content: renderConfluencePanel },
    structure: { title: 'panel_structure', badge: null, content: renderStructurePanel },
    liq: { title: 'panel_liq', badge: null, content: renderLiqPanel },
    patterns: { title: 'panel_patterns', badge: 'LIVE', content: renderPatternsPanel },
    history: { title: 'panel_history', badge: null, content: renderHistoryPanel },
    stats: { title: 'panel_stats', badge: 'LIVE', content: renderStatsPanel }
};

function initPanels() {
    if (STATE.panelsInitialized) return;
    
    const savedOrder = localStorage.getItem('btc_monitor_panels');
    const savedMinimized = localStorage.getItem('btc_monitor_minimized');
    
    if (savedOrder) {
        try {
            STATE.panelOrder = JSON.parse(savedOrder);
        } catch(e) {}
    }
    if (savedMinimized) {
        try {
            STATE.minimizedPanels = new Set(JSON.parse(savedMinimized));
        } catch(e) {}
    }
    
    renderPanels();
    setupDragAndDrop();
    STATE.panelsInitialized = true;
}

function renderPanels() {
    const leftContainer = document.getElementById('leftColContent');
    const rightContainer = document.getElementById('rightColContent');
    
    if (!leftContainer || !rightContainer) return;
    
    leftContainer.innerHTML = '';
    rightContainer.innerHTML = '';
    
    STATE.panelOrder.left.forEach(id => createPanel(id, leftContainer));
    STATE.panelOrder.right.forEach(id => createPanel(id, rightContainer));
}

function createPanel(id, container) {
    const def = PANEL_DEFINITIONS[id];
    if (!def) return;
    
    const panel = document.createElement('div');
    panel.className = `panel${STATE.minimizedPanels.has(id) ? ' minimized' : ''}`;
    panel.dataset.panelId = id;
    panel.draggable = true;
    
    const badgeHtml = def.badge ? `<span class="badge badge-live">${def.badge}</span>` : '';
    
    panel.innerHTML = `
        <div class="panel-header">
            <div class="panel-title">
                <span>${t(def.title)}</span>
                ${badgeHtml}
            </div>
            <div class="panel-controls">
                <button class="panel-btn" onclick="togglePanel('${id}')">${STATE.minimizedPanels.has(id) ? '▼' : '▲'}</button>
            </div>
        </div>
        <div class="panel-content" id="panel-${id}"></div>
    `;
    
    container.appendChild(panel);
    
    const contentEl = panel.querySelector('.panel-content');
    if (contentEl && def.content) {
        def.content(contentEl);
    }
}

function togglePanel(id) {
    if (STATE.minimizedPanels.has(id)) {
        STATE.minimizedPanels.delete(id);
    } else {
        STATE.minimizedPanels.add(id);
    }
    localStorage.setItem('btc_monitor_minimized', JSON.stringify([...STATE.minimizedPanels]));
    
    // Re-render just this panel's minimized state without full re-render
    const panel = document.querySelector(`.panel[data-panel-id="${id}"]`);
    if (panel) {
        panel.classList.toggle('minimized', STATE.minimizedPanels.has(id));
        const btn = panel.querySelector('.panel-btn');
        if (btn) btn.textContent = STATE.minimizedPanels.has(id) ? '▼' : '▲';
    }
}

function setupDragAndDrop() {
    let draggedPanel = null;
    let draggedFrom = null;
    
    document.addEventListener('dragstart', (e) => {
        if (e.target.classList.contains('panel')) {
            draggedPanel = e.target;
            draggedFrom = draggedPanel.parentElement.id;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
    });
    
    document.addEventListener('dragend', (e) => {
        if (e.target.classList.contains('panel')) {
            e.target.classList.remove('dragging');
            draggedPanel = null;
            draggedFrom = null;
            savePanelOrder();
        }
    });
    
    document.addEventListener('dragover', (e) => {
        e.preventDefault();
        const container = e.target.closest('.col-content');
        if (!container || !draggedPanel) return;
        
        const afterElement = getDragAfterElement(container, e.clientY);
        if (afterElement) {
            container.insertBefore(draggedPanel, afterElement);
        } else {
            container.appendChild(draggedPanel);
        }
    });
}

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.panel:not(.dragging)')];
    
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

function savePanelOrder() {
    const leftCol = document.getElementById('leftColContent');
    const rightCol = document.getElementById('rightColContent');
    
    if (leftCol) STATE.panelOrder.left = [...leftCol.querySelectorAll('.panel')].map(p => p.dataset.panelId).filter(id => id);
    if (rightCol) STATE.panelOrder.right = [...rightCol.querySelectorAll('.panel')].map(p => p.dataset.panelId).filter(id => id);
    
    localStorage.setItem('btc_monitor_panels', JSON.stringify(STATE.panelOrder));
}

// ============================================================
// RSI & STOCHRSI CALCULATIONS
// ============================================================
function calcRSI(closes, period = 14) {
    if (closes.length < period + 1) return [];
    
    const rsi = [];
    let gains = 0;
    let losses = 0;
    
    for (let i = 1; i <= period; i++) {
        const change = closes[i] - closes[i-1];
        if (change > 0) gains += change;
        else losses -= change;
    }
    
    let avgGain = gains / period;
    let avgLoss = losses / period;
    
    for (let i = period; i < closes.length; i++) {
        const change = closes[i] - closes[i-1];
        const gain = change > 0 ? change : 0;
        const loss = change < 0 ? -change : 0;
        
        avgGain = ((avgGain * (period - 1)) + gain) / period;
        avgLoss = ((avgLoss * (period - 1)) + loss) / period;
        
        const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
        rsi.push(100 - (100 / (1 + rs)));
    }
    
    const result = new Array(period).fill(null);
    return result.concat(rsi);
}

function calcStochRSI(closes, rsiPeriod = 14, stochPeriod = 14, kPeriod = 3, dPeriod = 3) {
    const rsi = calcRSI(closes, rsiPeriod);
    const validRsi = rsi.filter(v => v !== null);
    
    if (validRsi.length < stochPeriod) return { k: [], d: [] };
    
    const stochK = [];
    
    for (let i = stochPeriod - 1; i < validRsi.length; i++) {
        const slice = validRsi.slice(i - stochPeriod + 1, i + 1);
        const min = Math.min(...slice);
        const max = Math.max(...slice);
        const current = validRsi[i];
        
        if (max === min) {
            stochK.push(50);
        } else {
            stochK.push(((current - min) / (max - min)) * 100);
        }
    }
    
    const kSmoothed = calcSMA(stochK, kPeriod);
    const d = calcSMA(kSmoothed.filter(v => v !== null), dPeriod);
    
    const padLength = closes.length - kSmoothed.length;
    const paddedK = [...Array(padLength).fill(null), ...kSmoothed];
    const paddedD = [...Array(padLength - (kSmoothed.length - d.length)).fill(null), ...d];
    
    return { k: paddedK, d: paddedD };
}

function calcSMA(data, period) {
    const sma = [];
    for (let i = 0; i < data.length; i++) {
        if (i < period - 1) {
            sma.push(null);
        } else {
            const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
            sma.push(sum / period);
        }
    }
    return sma;
}

function detectDivergences(candles, rsi) {
    const divergences = [];
    if (candles.length < 20 || rsi.length < 20) return divergences;
    
    const priceSwings = detectSwingPoints(candles, 2);
    const rsiSwings = detectRSISwings(rsi, 2);
    
    const priceLows = priceSwings.filter(s => s.type === 'low').slice(-3);
    const rsiLows = rsiSwings.filter(s => s.type === 'low').slice(-3);
    
    if (priceLows.length >= 2 && rsiLows.length >= 2) {
        const p1 = priceLows[priceLows.length - 2];
        const p2 = priceLows[priceLows.length - 1];
        const r1 = rsiLows.find(r => Math.abs(r.index - p1.index) < 3);
        const r2 = rsiLows.find(r => Math.abs(r.index - p2.index) < 3);
        
        if (r1 && r2 && p2.price < p1.price && r2.value > r1.value) {
            divergences.push({
                type: 'bullish',
                startIndex: p1.index,
                endIndex: p2.index,
                startPrice: p1.price,
                endPrice: p2.price,
                startRsi: r1.value,
                endRsi: r2.value,
                strength: 'strong'
            });
        }
    }
    
    const priceHighs = priceSwings.filter(s => s.type === 'high').slice(-3);
    const rsiHighs = rsiSwings.filter(s => s.type === 'high').slice(-3);
    
    if (priceHighs.length >= 2 && rsiHighs.length >= 2) {
        const p1 = priceHighs[priceHighs.length - 2];
        const p2 = priceHighs[priceHighs.length - 1];
        const r1 = rsiHighs.find(r => Math.abs(r.index - p1.index) < 3);
        const r2 = rsiHighs.find(r => Math.abs(r.index - p2.index) < 3);
        
        if (r1 && r2 && p2.price > p1.price && r2.value < r1.value) {
            divergences.push({
                type: 'bearish',
                startIndex: p1.index,
                endIndex: p2.index,
                startPrice: p1.price,
                endPrice: p2.price,
                startRsi: r1.value,
                endRsi: r2.value,
                strength: 'strong'
            });
        }
    }
    
    return divergences;
}

function detectRSISwings(rsi, lookback = 2) {
    const swings = [];
    for (let i = lookback; i < rsi.length - lookback; i++) {
        if (rsi[i] === null) continue;
        
        let isHigh = true, isLow = true;
        for (let j = 1; j <= lookback; j++) {
            if (rsi[i-j] === null || rsi[i+j] === null) {
                isHigh = false;
                isLow = false;
                break;
            }
            if (rsi[i] <= rsi[i-j] || rsi[i] <= rsi[i+j]) isHigh = false;
            if (rsi[i] >= rsi[i-j] || rsi[i] >= rsi[i+j]) isLow = false;
        }
        
        if (isHigh) swings.push({ type: 'high', value: rsi[i], index: i });
        if (isLow) swings.push({ type: 'low', value: rsi[i], index: i });
    }
    return swings;
}

// ============================================================
// PANEL RENDER FUNCTIONS
// ============================================================
function renderMTFPanel(el) {
    el.innerHTML = '<div id="mtfContainer"></div>';
    // Render immediately if data exists
    if (Object.keys(STATE.tfBias).length > 0) renderMTFBias();
}

function renderMarketPanel(el) {
    el.innerHTML = `
        <div class="funding-grid">
            <div class="funding-cell">
                <div class="funding-label" data-i18n="header_funding">Funding Rate</div>
                <div class="funding-value" id="fundingRate" style="color:var(--text-2)">--</div>
            </div>
            <div class="funding-cell">
                <div class="funding-label">Next Funding</div>
                <div class="funding-value" id="nextFunding" style="color:var(--text-2);font-size:11px">--</div>
            </div>
        </div>
        <div style="margin-top:10px;padding-top:10px;border-top:1px solid var(--border)">
            <div class="signal-row"><span class="label">Open Interest</span><span class="value" id="oiValue">--</span></div>
            <div class="oi-bar"><div class="oi-fill" id="oiFill" style="width:0%"></div></div>
            <div class="signal-row" style="margin-top:6px"><span class="label">OI Change 24h</span><span class="value" id="oiChange">--</span></div>
        </div>
    `;
}

function renderSessionPanel(el) {
    el.innerHTML = `
        <div class="signal-row">
            <span class="label"><span class="session-indicator session-asian"></span>Asian</span>
            <span class="value" id="sessionAsian">00:00-09:00 UTC</span>
        </div>
        <div class="signal-row">
            <span class="label"><span class="session-indicator session-london"></span>London</span>
            <span class="value" id="sessionLondon">09:00-17:00 UTC</span>
        </div>
        <div class="signal-row">
            <span class="label"><span class="session-indicator session-ny"></span>New York</span>
            <span class="value" id="sessionNY">14:00-22:00 UTC</span>
        </div>
        <div class="signal-row" style="margin-top:6px;padding-top:6px;border-top:1px solid var(--border)">
            <span class="label">Active Session</span>
            <span class="value" id="activeSession" style="font-weight:700">--</span>
        </div>
        <div class="signal-row">
            <span class="label">Session High</span>
            <span class="value" id="sessionHigh">--</span>
        </div>
        <div class="signal-row">
            <span class="label">Session Low</span>
            <span class="value" id="sessionLow">--</span>
        </div>
    `;
}

function renderFibPanel(el) {
    el.innerHTML = `
        <div id="fibLevels">
            <div class="fib-row"><span class="fib-level">0%</span><span class="fib-price" id="fib0">--</span></div>
            <div class="fib-row"><span class="fib-level" style="color:var(--warn)">38.2%</span><span class="fib-price" id="fib382" style="color:var(--warn)">--</span></div>
            <div class="fib-row"><span class="fib-level" style="color:var(--text-1)">50%</span><span class="fib-price" id="fib50" style="color:var(--text-1)">--</span></div>
            <div class="fib-row"><span class="fib-level" style="color:var(--long)">61.8%</span><span class="fib-price" id="fib618" style="color:var(--long)">--</span></div>
            <div class="fib-row"><span class="fib-level" style="color:var(--short)">78.6%</span><span class="fib-price" id="fib786" style="color:var(--short)">--</span></div>
            <div class="fib-row"><span class="fib-level">100%</span><span class="fib-price" id="fib100">--</span></div>
        </div>
        <div style="margin-top:8px;font-size:8px;color:var(--text-3);text-align:center">
            Range: <span id="fibRange">--</span>
        </div>
    `;
}

function renderWyckoffPanel(el) {
    el.innerHTML = `
        <div class="signal-row"><span class="label">4h Bias</span><span class="value" id="wk4h">--</span></div>
        <div class="signal-row"><span class="label">15m Entry</span><span class="value" id="wk15m">--</span></div>
        <div class="signal-row"><span class="label">Konfluenz</span><span class="value" id="wkConf">--</span></div>
        <div class="wyckoff-bar" id="wkBar">
            <div class="wk-phase" data-p="A"></div>
            <div class="wk-phase" data-p="B"></div>
            <div class="wk-phase" data-p="C"></div>
            <div class="wk-phase" data-p="D"></div>
            <div class="wk-phase" data-p="E"></div>
        </div>
    `;
}

function renderFVGPanel(el) {
    el.innerHTML = '<div id="fvgList"></div>';
}

function renderRSIPanel(el) {
    el.innerHTML = `
        <div class="signal-row"><span class="label">RSI (14)</span><span class="value" id="rsiValue">--</span></div>
        <div class="signal-row"><span class="label">StochRSI %K</span><span class="value" id="stochKValue">--</span></div>
        <div class="signal-row"><span class="label">StochRSI %D</span><span class="value" id="stochDValue">--</span></div>
        <div style="margin-top:8px;padding-top:8px;border-top:1px solid var(--border)">
            <div class="signal-row"><span class="label">Divergenz</span><span class="value" id="divergenceValue">--</span></div>
            <div id="divergenceList" style="margin-top:4px;font-size:9px;"></div>
        </div>
    `;
}

function renderSignalPanel(el) {
    el.innerHTML = `
        <div class="signal-card" id="activeSignalCard">
            <div class="signal-card-header">
                <span class="signal-direction" id="sigDirection" style="color:var(--text-3)">${t('signal_waiting')}</span>
                <span class="signal-quality quality-none" id="sigQuality">--</span>
            </div>
            <div class="signal-row"><span class="label">Entry</span><span class="value" id="sigEntry">--</span></div>
            <div class="signal-row"><span class="label">Stop Loss</span><span class="value" id="sigSL">--</span></div>
            <div class="signal-row"><span class="label">TP1</span><span class="value" id="sigTP1">--</span></div>
            <div class="signal-row"><span class="label">TP2</span><span class="value" id="sigTP2">--</span></div>
            <div class="signal-row"><span class="label">R:R</span><span class="value" id="sigRR">--</span></div>
            <div class="signal-row"><span class="label">Category</span><span class="value" id="sigCategory">--</span></div>
            <div class="signal-row"><span class="label">Confluence</span><span class="value" id="sigConf">--</span></div>
            <div class="signal-row"><span class="label">Pattern</span><span class="value" id="sigPattern">--</span></div>
            <div class="signal-row"><span class="label">Reason</span><span class="value" id="sigReason">--</span></div>
            <div id="sigWarning" class="warning-text" style="display:none;"></div>
            <div class="cooldown-bar"><div class="cooldown-fill" id="cooldownFill" style="width:0%"></div></div>
        </div>
    `;
}

function renderConfluencePanel(el) {
    el.innerHTML = `
        <div class="signal-row"><span class="label">HTF Bias Align</span><span class="value" id="cfHTF">--</span></div>
        <div class="signal-row"><span class="label">FVG Entry</span><span class="value" id="cfFVG">--</span></div>
        <div class="signal-row"><span class="label">Fib Level</span><span class="value" id="cfFib">--</span></div>
        <div class="signal-row"><span class="label">Order Block</span><span class="value" id="cfOB">--</span></div>
        <div class="signal-row"><span class="label">MSS / BOS</span><span class="value" id="cfMSS">--</span></div>
        <div class="signal-row"><span class="label">Candle Pattern</span><span class="value" id="cfPattern">--</span></div>
        <div class="signal-row"><span class="label">Wyckoff MTF</span><span class="value" id="cfWyckoff">--</span></div>
        <div class="signal-row"><span class="label">Liq Sweep</span><span class="value" id="cfLiq">--</span></div>
        <div class="signal-row"><span class="label">RSI Divergence</span><span class="value" id="cfRSI">--</span></div>
        <div class="signal-row"><span class="label">Volume Confirm</span><span class="value" id="cfVol">--</span></div>
        <div class="signal-row"><span class="label">Trend Align</span><span class="value" id="cfTrend">--</span></div>
    `;
}

function renderStructurePanel(el) {
    el.innerHTML = `
        <div class="signal-row"><span class="label">Trend (LTF)</span><span class="value" id="mssTrend">--</span></div>
        <div class="signal-row"><span class="label">Last MSS</span><span class="value" id="mssLast">--</span></div>
        <div class="signal-row"><span class="label">Last BOS</span><span class="value" id="bosLast">--</span></div>
        <div class="signal-row"><span class="label">Swing High</span><span class="value" id="mssSwH">--</span></div>
        <div class="signal-row"><span class="label">Swing Low</span><span class="value" id="mssSwL">--</span></div>
    `;
}

function renderLiqPanel(el) {
    el.innerHTML = '<div id="liqList"></div>';
}

function renderPatternsPanel(el) {
    el.innerHTML = '<div id="patternList" style="font-size:9px;color:var(--text-2)">Waiting for data...</div>';
}

function renderHistoryPanel(el) {
    el.innerHTML = `
        <div class="history-tabs">
            <button class="history-tab active" onclick="setHistoryTab('active')" id="tabActive" data-i18n="tab_active">AKTIV</button>
            <button class="history-tab" onclick="setHistoryTab('closed')" id="tabClosed" data-i18n="tab_closed">ABGESCHLOSSEN</button>
        </div>
        <div class="history-filters">
            <button class="filter-chip active" onclick="setHistoryFilter('all')" id="filterAll" data-i18n="filter_all">Alle</button>
            <button class="filter-chip" onclick="setHistoryFilter('long')" id="filterLong" data-i18n="filter_long">Long</button>
            <button class="filter-chip" onclick="setHistoryFilter('short')" id="filterShort" data-i18n="filter_short">Short</button>
            <button class="filter-chip" onclick="setHistoryFilter('risky')" id="filterRisky" data-i18n="filter_risky">Risky</button>
            <button class="filter-chip" onclick="setHistoryFilter('safe')" id="filterSafe" data-i18n="filter_safe">Safe</button>
        </div>
        <div id="signalHistory" style="max-height: 200px; overflow-y: auto;">
            <div style="text-align:center;color:var(--text-3);padding:12px;font-size:10px;">No signals yet</div>
        </div>
        <button class="load-more-btn" id="loadMoreBtn" style="display:none;" onclick="loadMoreHistory()">Load more</button>
    `;
}

function renderStatsPanel(el) {
    el.innerHTML = `
        <div class="bt-grid">
            <div class="bt-cell"><div class="bt-label" data-i18n="filter_risky">Risky</div><div class="bt-value" id="statRisky" style="color:var(--text-2)">0</div></div>
            <div class="bt-cell"><div class="bt-label" data-i18n="category_neutral">Neutral</div><div class="bt-value" id="statNeutral" style="color:var(--text-2)">0</div></div>
            <div class="bt-cell"><div class="bt-label">Win Rate</div><div class="bt-value" id="statWinRate" style="color:var(--text-2)">--</div></div>
            <div class="bt-cell"><div class="bt-label">Total R</div><div class="bt-value" id="statTotalR" style="color:var(--text-2)">--</div></div>
        </div>
    `;
}

// ============================================================
// DATA FETCHING
// ============================================================
async function fetchCandles(interval, limit = 500) {
    try {
        const res = await fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${interval}&limit=${limit}`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        if (!data || !data.length) return null;
        return data.map(d => ({ t: d[0], o: +d[1], h: +d[2], l: +d[3], c: +d[4], v: +d[5] }));
    } catch (e) { console.error(`Fetch ${interval}:`, e); return null; }
}

async function fetchFundingData() {
    try {
        const fundRes = await fetch('https://fapi.binance.com/fapi/v1/fundingRate?symbol=BTCUSDT&limit=1');
        if (fundRes.ok) {
            const fundData = await fundRes.json();
            if (fundData.length > 0) {
                STATE.funding.rate = parseFloat(fundData[0].fundingRate);
                STATE.funding.nextFunding = fundData[0].fundingTime;
            }
        }
        
        const oiRes = await fetch('https://fapi.binance.com/fapi/v1/openInterest?symbol=BTCUSDT');
        if (oiRes.ok) {
            const oiData = await oiRes.json();
            STATE.openInterest.value = parseFloat(oiData.openInterest);
        }
        
        updateFundingUI();
    } catch (e) { console.error('Funding fetch error:', e); }
}

function updateFundingUI() {
    const rate = STATE.funding.rate;
    const ratePercent = (rate * 100).toFixed(4);
    const isPositive = rate >= 0;
    
    safeSetText('fundingRate', (isPositive ? '+' : '') + ratePercent + '%', isPositive ? 'var(--short)' : 'var(--long)');
    safeSetText('headerFunding', (isPositive ? '+' : '') + ratePercent + '%', isPositive ? 'var(--short)' : 'var(--long)');
    
    const nextTime = STATE.funding.nextFunding;
    if (nextTime) {
        const diff = nextTime - Date.now();
        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        safeSetText('nextFunding', `${hours}h ${minutes}m`);
        safeSetText('headerOI', (STATE.openInterest.value / 1000000).toFixed(2) + 'M');
    }
    
    const oiM = (STATE.openInterest.value / 1000000000).toFixed(2);
    safeSetText('oiValue', oiM + ' B');
    
    const oiFill = document.getElementById('oiFill');
    if (oiFill) oiFill.style.width = '50%';
}

async function loadAllTimeframes() {
    const tfs = ['1m', '3m', '5m', '15m', '30m', '1h', '2h', '4h'];
    const results = await Promise.all(tfs.map(tf => fetchCandles(tf, 500)));
    tfs.forEach((tf, i) => { if (results[i]) STATE.tfData[tf] = results[i]; });

    const ref = STATE.tfData['4h'] || STATE.tfData['1h'] || STATE.tfData['5m'];
    if (ref && ref.length) STATE.price = ref[ref.length - 1].c;

    if (STATE.tfData['1h'] && STATE.tfData['1h'].length >= 24) {
        STATE.openPrice24h = STATE.tfData['1h'][STATE.tfData['1h'].length - 24].o;
    }
    
    updateRSIData();
}

function updateRSIData() {
    const candles = STATE.tfData[STATE.currentTF];
    if (!candles || candles.length < 20) return;
    
    const closes = candles.map(c => c.c);
    STATE.rsiData = calcRSI(closes, 14);
    STATE.stochRsiData = calcStochRSI(closes, 14, 14, 3, 3);
    STATE.divergences = detectDivergences(candles, STATE.rsiData);
}

// ============================================================
// SESSION HANDLING
// ============================================================
function detectSession() {
    const now = new Date();
    const utcHours = now.getUTCHours();
    const utcMinutes = now.getUTCMinutes();
    const totalMinutes = utcHours * 60 + utcMinutes;
    
    let sessionName = 'none';
    let sessionColor = '';
    let startMin = 0, endMin = 0;
    
    if (totalMinutes >= 0 && totalMinutes < 540) {
        sessionName = 'Asian';
        sessionColor = '#ffd700';
        startMin = 0;
        endMin = 540;
    } else if (totalMinutes >= 540 && totalMinutes < 1020) {
        sessionName = 'London';
        sessionColor = '#00bcd4';
        startMin = 540;
        endMin = 1020;
        if (totalMinutes >= 840) {
            sessionName = 'London/NY';
            sessionColor = '#ff5722';
        }
    } else if (totalMinutes >= 840 && totalMinutes < 1320) {
        sessionName = 'New York';
        sessionColor = '#ff5722';
        startMin = 840;
        endMin = 1320;
    } else {
        sessionName = 'Closed';
        sessionColor = '#444e5f';
        startMin = 1320;
        endMin = 1440;
    }
    
    STATE.currentSession = {
        name: sessionName,
        color: sessionColor,
        start: startMin,
        end: endMin,
        utcHours: utcHours
    };
    
    calculateSessionRange();
    updateSessionUI();
}

function calculateSessionRange() {
    const candles = STATE.tfData[STATE.currentTF];
    if (!candles || !candles.length) return;
    
    const now = Date.now();
    const sessionStart = new Date();
    sessionStart.setUTCHours(Math.floor(STATE.currentSession.start / 60), 0, 0, 0);
    
    const relevantCandles = candles.filter(c => c.t >= sessionStart.getTime() && c.t <= now);
    if (relevantCandles.length) {
        STATE.currentSession.high = Math.max(...relevantCandles.map(c => c.h));
        STATE.currentSession.low = Math.min(...relevantCandles.map(c => c.l));
    }
}

function updateSessionUI() {
    const s = STATE.currentSession;
    safeSetText('activeSession', s.name, s.color);
    safeSetText('headerSession', s.name, s.color);
    
    if (s.high && s.low) {
        safeSetText('sessionHigh', '$' + s.high.toFixed(0), 'var(--short)');
        safeSetText('sessionLow', '$' + s.low.toFixed(0), 'var(--long)');
    }
}

// ============================================================
// FIBONACCI RETRACEMENT
// ============================================================
function calculateFibonacci() {
    const candles = STATE.tfData[STATE.currentTF];
    if (!candles || candles.length < 20) return;
    
    const lookback = Math.min(50, candles.length);
    const recent = candles.slice(-lookback);
    
    let swingHigh = { price: 0, time: 0 };
    let swingLow = { price: Infinity, time: 0 };
    
    recent.forEach((c, i) => {
        if (c.h > swingHigh.price) swingHigh = { price: c.h, time: c.t, index: i };
        if (c.l < swingLow.price) swingLow = { price: c.l, time: c.t, index: i };
    });
    
    const isUptrend = swingLow.time > swingHigh.time;
    
    let startPrice, endPrice;
    if (isUptrend) {
        startPrice = swingLow.price;
        endPrice = recent[recent.length-1].h;
    } else {
        startPrice = swingHigh.price;
        endPrice = recent[recent.length-1].l;
    }
    
    const range = Math.abs(startPrice - endPrice);
    const levels = {
        0: startPrice,
        382: isUptrend ? startPrice + (range * 0.382) : startPrice - (range * 0.382),
        50: isUptrend ? startPrice + (range * 0.5) : startPrice - (range * 0.5),
        618: isUptrend ? startPrice + (range * 0.618) : startPrice - (range * 0.618),
        786: isUptrend ? startPrice + (range * 0.786) : startPrice - (range * 0.786),
        100: endPrice
    };
    
    STATE.fibLevels = {
        high: Math.max(startPrice, endPrice),
        low: Math.min(startPrice, endPrice),
        isUptrend,
        levels,
        swingHigh,
        swingLow
    };
    
    updateFibUI();
}

function updateFibUI() {
    const fib = STATE.fibLevels;
    const ids = ['fib0', 'fib382', 'fib50', 'fib618', 'fib786', 'fib100'];
    const keys = [0, 382, 50, 618, 786, 100];
    
    ids.forEach((id, i) => {
        const el = document.getElementById(id);
        if (el && fib.levels[keys[i]]) el.textContent = '$' + fib.levels[keys[i]].toFixed(0);
    });
    
    const fibRangeEl = document.getElementById('fibRange');
    if (fibRangeEl) {
        const range = Math.abs(fib.high - fib.low);
        fibRangeEl.textContent = '$' + range.toFixed(0) + ' (' + ((range/fib.low)*100).toFixed(1) + '%)';
    }
}

// ============================================================
// MATH HELPERS
// ============================================================
function calcEMA(data, period) {
    if (!data.length) return [];
    const k = 2 / (period + 1);
    const ema = [data[0]];
    for (let i = 1; i < data.length; i++) ema.push(data[i] * k + ema[i - 1] * (1 - k));
    return ema;
}

function calcATR(candles, period = 14) {
    const atr = [];
    for (let i = 0; i < candles.length; i++) {
        const tr = i === 0 ? candles[i].h - candles[i].l :
            Math.max(candles[i].h - candles[i].l, Math.abs(candles[i].h - candles[i-1].c), Math.abs(candles[i].l - candles[i-1].c));
        atr.push(i < period ? tr : (atr[i-1] * (period - 1) + tr) / period);
    }
    return atr;
}

// ============================================================
// CANDLE PATTERNS
// ============================================================
function detectCandlePatterns(candles) {
    if (candles.length < 5) return null;
    const i = candles.length - 1;
    const curr = candles[i];
    const prev = candles[i-1];
    const prev2 = candles[i-2];
    
    const body = Math.abs(curr.c - curr.o);
    const range = curr.h - curr.l;
    const upperWick = curr.h - Math.max(curr.c, curr.o);
    const lowerWick = Math.min(curr.c, curr.o) - curr.l;
    
    const isBull = curr.c > curr.o;
    const isBear = curr.c < curr.o;
    const prevIsBull = prev.c > prev.o;
    const prevIsBear = prev.c < prev.o;
    
    let patterns = [];
    
    if (isBull && prevIsBear && curr.o < prev.c && curr.c > prev.o) {
        patterns.push({ name: 'Bull Engulfing', type: 'bull', strength: 2 });
    } else if (isBear && prevIsBull && curr.o > prev.c && curr.c < prev.o) {
        patterns.push({ name: 'Bear Engulfing', type: 'bear', strength: 2 });
    }
    
    if (isBull && lowerWick > body * 2 && upperWick < body * 0.5 && range > body * 2) {
        patterns.push({ name: 'Hammer', type: 'bull', strength: 1.5 });
    }
    
    if (isBear && upperWick > body * 2 && lowerWick < body * 0.5 && range > body * 2) {
        patterns.push({ name: 'Shooting Star', type: 'bear', strength: 1.5 });
    }
    
    if (lowerWick > body * 2.5 && upperWick < body * 0.3) {
        patterns.push({ name: 'Pin Bar', type: 'bull', strength: 1.5 });
    } else if (upperWick > body * 2.5 && lowerWick < body * 0.3) {
        patterns.push({ name: 'Pin Bar', type: 'bear', strength: 1.5 });
    }
    
    if (body < range * 0.05 && range > 0) {
        patterns.push({ name: 'Doji', type: 'neutral', strength: 0.5 });
    }
    
    if (prev2 && prev && candles[i-2].c < candles[i-2].o && 
        Math.abs(prev.c - prev.o) < (prev.h - prev.l) * 0.3 && 
        curr.c > curr.o && curr.c > (prev2.o + prev2.c) / 2) {
        patterns.push({ name: 'Morning Star', type: 'bull', strength: 2.5 });
    }
    
    if (prev2 && prev && candles[i-2].c > candles[i-2].o && 
        Math.abs(prev.c - prev.o) < (prev.h - prev.l) * 0.3 && 
        curr.c < curr.o && curr.c < (prev2.o + prev2.c) / 2) {
        patterns.push({ name: 'Evening Star', type: 'bear', strength: 2.5 });
    }
    
    return patterns.length > 0 ? patterns : null;
}

function renderPatterns(patterns) {
    const el = document.getElementById('patternList');
    if (!el) return;
    
    if (!patterns) {
        el.innerHTML = '<span style="color:var(--text-3)">No patterns detected</span>';
        return;
    }
    el.innerHTML = patterns.map(p => 
        `<span class="candle-pattern-tag pattern-${p.type}">${p.name} (${p.strength})</span>`
    ).join('');
}

// ============================================================
// MTF BIAS
// ============================================================
function analyzeMTFBias() {
    const tfs = ['5m', '15m', '30m', '1h', '2h', '4h'];
    tfs.forEach(tf => {
        const data = STATE.tfData[tf];
        if (!data || data.length < 100) { STATE.tfBias[tf] = { bias: 'neutral', strength: 0, score: 0 }; return; }
        const closes = data.map(d => d.c);
        const ema20 = calcEMA(closes, 20), ema50 = calcEMA(closes, 50), ema100 = calcEMA(closes, 100);
        const L = closes.length - 1, price = closes[L];
        let score = 0;
        if (ema20[L] > ema50[L] && ema50[L] > ema100[L]) score += 4;
        else if (ema20[L] < ema50[L] && ema50[L] < ema100[L]) score -= 4;
        if (price > ema20[L]) score += 1; else score -= 1;
        if (price > ema50[L]) score += 1; else score -= 1;
        if (price > ema100[L]) score += 1; else score -= 1;
        const bullC = data.slice(-5).filter(c => c.c > c.o).length;
        score += (bullC - 2.5);
        const strength = Math.min(100, Math.abs(score / 10) * 100);
        STATE.tfBias[tf] = { bias: score > 2 ? 'bullish' : score < -2 ? 'bearish' : 'neutral', strength, score };
    });
    const weights = { '4h': 4, '2h': 3, '1h': 2.5, '30m': 2, '15m': 1.5, '5m': 0.5 };
    let ts = 0, tw = 0;
    tfs.forEach(tf => { if (STATE.tfBias[tf]) { ts += STATE.tfBias[tf].score * (weights[tf]||1); tw += weights[tf]||1; }});
    const h = tw > 0 ? ts / tw : 0;
    STATE.htfBias = h > 1.5 ? 'BULLISH' : h < -1.5 ? 'BEARISH' : 'NEUTRAL';
}

function renderMTFBias() {
    const el = document.getElementById('mtfContainer');
    if (!el) return;
    
    const tfs = ['5m', '15m', '30m', '1h', '2h', '4h'];
    el.innerHTML = tfs.map(tf => {
        const b = STATE.tfBias[tf] || { bias: 'neutral', strength: 0, score: 0 };
        const col = b.bias === 'bullish' ? 'var(--long)' : b.bias === 'bearish' ? 'var(--short)' : 'var(--text-3)';
        const pct = Math.min(50, b.strength / 2);
        const left = b.score > 0 ? '50%' : `${50 - pct}%`;
        return `<div class="mtf-row"><span class="mtf-tf">${tf}</span>
            <div class="mtf-bar-wrap"><div class="mtf-bar-center"></div>
            <div class="mtf-bar-fill" style="left:${left};width:${pct}%;background:${col}"></div></div>
            <span style="color:${col};font-weight:600;text-align:right">${b.bias.toUpperCase()}</span></div>`;
    }).join('');
    
    safeSetText('htfBias', STATE.htfBias, STATE.htfBias === 'BULLISH' ? 'var(--long)' : STATE.htfBias === 'BEARISH' ? 'var(--short)' : 'var(--text-2)');
}

// ============================================================
// SWING POINTS & MSS/BOS
// ============================================================
function detectSwingPoints(candles, lb = 3) {
    const sw = [];
    for (let i = lb; i < candles.length - lb; i++) {
        let isH = true, isL = true;
        for (let j = 1; j <= lb; j++) {
            if (candles[i].h <= candles[i-j].h || candles[i].h <= candles[i+j].h) isH = false;
            if (candles[i].l >= candles[i-j].l || candles[i].l >= candles[i+j].l) isL = false;
        }
        if (isH) sw.push({ type: 'high', price: candles[i].h, index: i, time: candles[i].t });
        if (isL) sw.push({ type: 'low', price: candles[i].l, index: i, time: candles[i].t });
    }
    return sw;
}

function detectMSSandBOS(candles) {
    const swings = detectSwingPoints(candles, 3);
    STATE.swingPoints = swings;
    STATE.mssEvents = [];
    STATE.bosEvents = [];
    let lastH = null, lastL = null, trend = 'neutral';

    for (const sw of swings) {
        if (sw.type === 'high') {
            if (lastH) {
                if (sw.price > lastH.price) {
                    if (trend === 'bearish') STATE.mssEvents.push({ type: 'MSS_BULL', price: sw.price, time: sw.time, index: sw.index });
                    else STATE.bosEvents.push({ type: 'BOS_BULL', price: sw.price, time: sw.time, index: sw.index });
                    trend = 'bullish';
                } else if (trend === 'bullish') {
                    STATE.mssEvents.push({ type: 'MSS_BEAR', price: sw.price, time: sw.time, index: sw.index });
                    trend = 'bearish';
                }
            }
            lastH = sw;
        } else {
            if (lastL) {
                if (sw.price < lastL.price) {
                    if (trend === 'bullish') STATE.mssEvents.push({ type: 'MSS_BEAR', price: sw.price, time: sw.time, index: sw.index });
                    else STATE.bosEvents.push({ type: 'BOS_BEAR', price: sw.price, time: sw.time, index: sw.index });
                    trend = 'bearish';
                } else if (trend === 'bearish') {
                    STATE.mssEvents.push({ type: 'MSS_BULL', price: sw.price, time: sw.time, index: sw.index });
                    trend = 'bullish';
                }
            }
            lastL = sw;
        }
    }
    STATE.currentTrend = trend;

    safeSetText('mssTrend', trend.toUpperCase(), trend === 'bullish' ? 'var(--long)' : trend === 'bearish' ? 'var(--short)' : 'var(--text-2)');
    
    const lm = STATE.mssEvents[STATE.mssEvents.length - 1];
    const lb = STATE.bosEvents[STATE.bosEvents.length - 1];
    
    if (lm) safeSetText('mssLast', `${lm.type.replace('_',' ')} @ $${lm.price.toFixed(0)}`, lm.type.includes('BULL') ? 'var(--long)' : 'var(--short)');
    if (lb) safeSetText('bosLast', `${lb.type.replace('_',' ')} @ $${lb.price.toFixed(0)}`, lb.type.includes('BULL') ? 'var(--long)' : 'var(--short)');
    if (lastH) safeSetText('mssSwH', '$' + lastH.price.toFixed(0), 'var(--short)');
    if (lastL) safeSetText('mssSwL', '$' + lastL.price.toFixed(0), 'var(--long)');
}

// ============================================================
// FVG
// ============================================================
function detectFVGs(candles) {
    const threshold = FVG_THRESHOLDS[STATE.currentTF] || 0.005;
    const fvgs = [];
    
    for (let i = 2; i < candles.length; i++) {
        const p = candles[i-2], c = candles[i];
        const bullishGap = (c.l - p.h) / p.h;
        const bearishGap = (p.l - c.h) / p.l;
        
        if (c.l > p.h && bullishGap >= threshold) {
            fvgs.push({ type: 'bullish', top: c.l, bottom: p.h, idx: i, time: c.t, status: 'open', filled: 0, size: bullishGap });
        }
        if (c.h < p.l && bearishGap >= threshold) {
            fvgs.push({ type: 'bearish', top: p.l, bottom: c.h, idx: i, time: c.t, status: 'open', filled: 0, size: bearishGap });
        }
    }
    
    fvgs.forEach(f => {
        for (let i = f.idx + 1; i < candles.length; i++) {
            const c = candles[i];
            if (f.type === 'bullish') {
                if (c.l <= f.bottom) { f.status = 'filled'; f.filled = 1; break; }
                if (c.l < f.top) f.filled = Math.max(f.filled, (f.top - c.l) / (f.top - f.bottom));
            } else {
                if (c.h >= f.top) { f.status = 'filled'; f.filled = 1; break; }
                if (c.h > f.bottom) f.filled = Math.max(f.filled, (c.h - f.bottom) / (f.top - f.bottom));
            }
        }
        if (f.filled >= 0.7 && f.status !== 'filled') f.status = 'partial';
    });
    
    STATE.fvgs = fvgs.filter(f => f.status !== 'filled');
}

function renderFVGList() {
    const el = document.getElementById('fvgList');
    if (!el) return;
    
    const threshold = FVG_THRESHOLDS[STATE.currentTF] || 0.005;
    const open = STATE.fvgs.filter(f => f.status !== 'filled').slice(-8);
    
    if (!open.length) { 
        el.innerHTML = `<div style="text-align:center;color:var(--text-3);padding:8px;font-size:10px">No FVGs >${(threshold*100).toFixed(1)}%</div>`; 
        return; 
    }
    
    el.innerHTML = open.map(f => {
        const dist = f.type === 'bullish' ? ((STATE.price - f.top) / STATE.price * 100).toFixed(2) : ((f.bottom - STATE.price) / STATE.price * 100).toFixed(2);
        return `<div class="fvg-item ${f.type === 'bullish' ? 'bull' : 'bear'}">
            <span>$${f.bottom.toFixed(0)} – $${f.top.toFixed(0)}</span>
            <span style="color:var(--text-2);font-size:8px">${(f.size*100).toFixed(1)}%</span>
            <span style="color:var(--text-2);font-size:9px">${dist}%</span>
            <span class="fvg-tag ${f.status === 'open' ? 'tag-open' : 'tag-partial'}">${f.status.toUpperCase()}</span>
        </div>`;
    }).join('');
}

// ============================================================
// ORDER BLOCKS & LIQ
// ============================================================
function detectOrderBlocks(candles) {
    STATE.orderBlocks = [];
    for (let i = 2; i < candles.length - 1; i++) {
        const c0 = candles[i-1], c1 = candles[i], c2 = candles[i+1];
        if (c0.c < c0.o && c1.c > c1.o && (c1.c - c1.o) / c1.o > 0.002 && c2.c > c1.h)
            STATE.orderBlocks.push({ type: 'bullish', high: c0.h, low: c0.l, idx: i-1, time: c0.t, mitigated: false });
        if (c0.c > c0.o && c1.c < c1.o && (c1.o - c1.c) / c1.o > 0.002 && c2.c < c1.l)
            STATE.orderBlocks.push({ type: 'bearish', high: c0.h, low: c0.l, idx: i-1, time: c0.t, mitigated: false });
    }
    STATE.orderBlocks.forEach(ob => {
        for (let i = ob.idx + 3; i < candles.length; i++) {
            if (ob.type === 'bullish' && candles[i].l < ob.low) { ob.mitigated = true; break; }
            if (ob.type === 'bearish' && candles[i].h > ob.high) { ob.mitigated = true; break; }
        }
    });
    STATE.orderBlocks = STATE.orderBlocks.filter(ob => !ob.mitigated).slice(-10);
}

function detectLiquidityLevels() {
    STATE.liquidityLevels = [];
    const highs = STATE.swingPoints.filter(s => s.type === 'high').map(s => s.price);
    const lows = STATE.swingPoints.filter(s => s.type === 'low').map(s => s.price);

    function cluster(lvls, tol = 0.001) {
        const cl = [], used = new Set();
        for (let i = 0; i < lvls.length; i++) {
            if (used.has(i)) continue;
            let g = [lvls[i]];
            for (let j = i+1; j < lvls.length; j++) { if (!used.has(j) && Math.abs(lvls[j] - lvls[i]) / lvls[i] < tol) { g.push(lvls[j]); used.add(j); }}
            if (g.length >= 2) cl.push({ price: g.reduce((a,b)=>a+b,0)/g.length, touches: g.length });
            used.add(i);
        }
        return cl;
    }

    const eqH = cluster(highs).map(c => ({ ...c, type: 'EQH' }));
    const eqL = cluster(lows).map(c => ({ ...c, type: 'EQL' }));
    if (highs.length) eqH.push({ price: Math.max(...highs.slice(-10)), touches: 1, type: 'BSL' });
    if (lows.length) eqL.push({ price: Math.min(...lows.slice(-10)), touches: 1, type: 'SSL' });

    STATE.liquidityLevels = [...eqH, ...eqL].sort((a, b) => Math.abs(a.price - STATE.price) - Math.abs(b.price - STATE.price)).slice(0, 8);
}

function renderLiquidity() {
    const el = document.getElementById('liqList');
    if (!el) return;
    
    if (!STATE.liquidityLevels.length) { 
        el.innerHTML = '<div style="text-align:center;color:var(--text-3);padding:8px;font-size:10px">No clusters</div>'; 
        return; 
    }
    
    const mx = Math.max(...STATE.liquidityLevels.map(l => l.touches));
    
    el.innerHTML = STATE.liquidityLevels.map(l => {
        const dist = ((l.price / STATE.price - 1) * 100).toFixed(2);
        const above = l.price > STATE.price;
        return `<div class="liq-row">
            <span style="color:${above ? 'var(--short)' : 'var(--long)'};font-weight:600;min-width:45px">${l.type}</span>
            <span style="min-width:70px">$${l.price.toFixed(0)}</span>
            <div class="liq-bar-wrap">
                <div class="liq-bar-fill ${above ? 'above' : 'below'}" style="width:${(l.touches/mx*100).toFixed(0)}%"></div>
            </div>
            <span style="color:var(--text-2);min-width:45px;text-align:right">${dist}%</span>
        </div>`;
    }).join('');
}

// ============================================================
// WYCKOFF MTF
// ============================================================
function analyzeWyckoffMTF() {
    const data4h = STATE.tfData['4h'];
    if (data4h && data4h.length >= 60) {
        STATE.wyckoff.htf = analyzeSingleWyckoff(data4h, '4h');
    }
    
    const data15m = STATE.tfData['15m'];
    if (data15m && data15m.length >= 60) {
        STATE.wyckoff.ltf = analyzeSingleWyckoff(data15m, '15m');
    } else if (STATE.tfData['30m']) {
        STATE.wyckoff.ltf = analyzeSingleWyckoff(STATE.tfData['30m'], '30m');
    }
    
    const htf = STATE.wyckoff.htf;
    const ltf = STATE.wyckoff.ltf;
    
    let combined = 'neutral';
    if (htf.phase === 'accumulation' && (ltf.phase === 'accumulation' || ltf.phase === 'neutral')) {
        combined = 'strong_bull';
    } else if (htf.phase === 'distribution' && (ltf.phase === 'distribution' || ltf.phase === 'neutral')) {
        combined = 'strong_bear';
    } else if (htf.phase === 'accumulation' && ltf.phase === 'distribution') {
        combined = 'conflict';
    } else if (htf.phase === 'distribution' && ltf.phase === 'accumulation') {
        combined = 'conflict';
    }
    
    STATE.wyckoff.combined = combined;
    
    safeSetText('wk4h', htf.subPhase || htf.phase, htf.phase === 'accumulation' ? 'var(--long)' : htf.phase === 'distribution' ? 'var(--short)' : 'var(--text-2)');
    safeSetText('wk15m', ltf.subPhase || ltf.phase, ltf.phase === 'accumulation' ? 'var(--long)' : ltf.phase === 'distribution' ? 'var(--short)' : 'var(--text-2)');
    
    let wkConfText = 'NEUTRAL';
    let wkConfColor = 'var(--text-2)';
    if (combined === 'strong_bull') { wkConfText = '✓ BULL ALIGN'; wkConfColor = 'var(--long)'; }
    else if (combined === 'strong_bear') { wkConfText = '✓ BEAR ALIGN'; wkConfColor = 'var(--short)'; }
    else if (combined === 'conflict') { wkConfText = '⚠ CONFLICT'; wkConfColor = 'var(--warn)'; }
    safeSetText('wkConf', wkConfText, wkConfColor);
    
    const wkBar = document.getElementById('wkBar');
    if (wkBar) {
        const pm = { 'Range':'B','Spring':'C','Test':'C','SOS':'D','Upthrust':'C','LPSY':'C','SOW':'D' };
        const ap = pm[htf.subPhase] || 'A';
        wkBar.querySelectorAll('.wk-phase').forEach(e => { 
            e.classList.remove('active','current'); 
            if (htf.phase !== 'none' && e.dataset.p <= ap) e.classList.add('active'); 
            if (htf.phase !== 'none' && e.dataset.p === ap) e.classList.add('current'); 
        });
    }
}

function analyzeSingleWyckoff(data, tf) {
    const rec = data.slice(-80);
    const highs = rec.map(d => d.h), lows = rec.map(d => d.l), closes = rec.map(d => d.c), vols = rec.map(d => d.v);
    const maxH = Math.max(...highs), minL = Math.min(...lows), range = maxH - minL;
    if (range === 0) return { phase: 'none', subPhase: '', confidence: 0 };
    const last = closes[closes.length-1], pos = (last - minL) / range;
    const avgV = vols.reduce((a,b)=>a+b,0)/vols.length, recV = vols.slice(-5).reduce((a,b)=>a+b,0)/5, vr = recV/avgV;
    const isRange = range / minL < 0.08;
    let phase = 'none', sub = '', conf = 0;
    const pc = closes[closes.length-2], p2 = closes[closes.length-3];
    const revUp = last > pc && pc < p2, revDown = last < pc && pc > p2;

    if (isRange) {
        if (pos < 0.15 && vr > 1.3 && revUp) { phase = 'accumulation'; sub = 'Spring'; conf = Math.min(90, vr*40); }
        else if (pos < 0.2 && vr < 1.0 && revUp) { phase = 'accumulation'; sub = 'Test'; conf = 50; }
        else if (pos > 0.85 && vr > 1.2) { phase = 'accumulation'; sub = 'SOS'; conf = Math.min(80, vr*35); }
        else if (pos > 0.85 && vr > 1.3 && revDown) { phase = 'distribution'; sub = 'Upthrust'; conf = Math.min(90, vr*40); }
        else if (pos > 0.8 && vr < 1.0 && revDown) { phase = 'distribution'; sub = 'LPSY'; conf = 50; }
        else if (pos < 0.15 && vr > 1.2) { phase = 'distribution'; sub = 'SOW'; conf = Math.min(80, vr*35); }
        else if (pos < 0.4) { phase = 'accumulation'; sub = 'Range'; conf = 30; }
        else if (pos > 0.6) { phase = 'distribution'; sub = 'Range'; conf = 30; }
    }
    return { phase, subPhase: sub, confidence: conf, posInRange: pos, volRatio: vr };
}

// ============================================================
// SIGNAL GENERATION WITH CATEGORIES
// ============================================================
function generateSignals() {
    const candles = STATE.tfData[STATE.currentTF];
    if (!candles || candles.length < 50) return;
    if (Date.now() < STATE.signalCooldown) { updateCooldownBar(); return; }

    const price = STATE.price;
    const atr = calcATR(candles, 14);
    const atrVal = atr[atr.length-1];
    
    let ls = 0, ss = 0;
    let reasons = { long: [], short: [] };
    let warnings = { long: [], short: [] };
    
    // 1. HTF Bias
    if (STATE.htfBias === 'BULLISH') { ls += 2; reasons.long.push('HTF Bullish'); }
    else if (STATE.htfBias === 'BEARISH') { ss += 2; reasons.short.push('HTF Bearish'); }
    else {
        renderNoSignal(0);
        return;
    }
    updateConfluenceUI('cfHTF', STATE.htfBias, STATE.htfBias === 'BULLISH' ? 'var(--long)' : 'var(--short)');

    // 2. FVG
    const nbf = STATE.fvgs.find(f => f.type === 'bullish' && f.status === 'open' && price >= f.bottom && price <= f.top * 1.005);
    const nbr = STATE.fvgs.find(f => f.type === 'bearish' && f.status === 'open' && price <= f.top && price >= f.bottom * 0.995);
    if (nbf) { ls += 2; reasons.long.push(`FVG ${(nbf.size*100).toFixed(1)}%`); }
    if (nbr) { ss += 2; reasons.short.push(`FVG ${(nbr.size*100).toFixed(1)}%`); }
    const fvgText = nbf ? `✓ ${(nbf.size*100).toFixed(1)}%` : nbr ? `✓ ${(nbr.size*100).toFixed(1)}%` : '--';
    const fvgColor = nbf ? 'var(--long)' : nbr ? 'var(--short)' : 'var(--text-3)';
    updateConfluenceUI('cfFVG', fvgText, fvgColor);

    // 3. Fibonacci
    const fib = STATE.fibLevels;
    let nearFib = false;
    let fibLevel = '';
    
    if (fib.levels[618]) {
        const dist618 = Math.abs(price - fib.levels[618]) / price;
        const dist382 = Math.abs(price - fib.levels[382]) / price;
        const dist50 = Math.abs(price - fib.levels[50]) / price;
        
        if (dist618 < 0.002) { nearFib = true; fibLevel = '61.8%'; if (fib.isUptrend) { ls += 1.5; reasons.long.push('Fib 61.8%'); } else { ss += 1.5; reasons.short.push('Fib 61.8%'); }}
        else if (dist382 < 0.002) { nearFib = true; fibLevel = '38.2%'; if (!fib.isUptrend) { ls += 1; reasons.long.push('Fib 38.2%'); } else { ss += 1; reasons.short.push('Fib 38.2%'); }}
        else if (dist50 < 0.002) { nearFib = true; fibLevel = '50%'; ls += 0.5; ss += 0.5; }
    }
    
    updateConfluenceUI('cfFib', nearFib ? `✓ ${fibLevel}` : '—', nearFib ? 'var(--accent)' : 'var(--text-3)');

    // 4. OB
    const nbo = STATE.orderBlocks.find(ob => ob.type === 'bullish' && price >= ob.low && price <= ob.high * 1.002);
    const nso = STATE.orderBlocks.find(ob => ob.type === 'bearish' && price <= ob.high && price >= ob.low * 0.998);
    if (nbo) { ls += 1.5; reasons.long.push('Bull OB'); }
    if (nso) { ss += 1.5; reasons.short.push('Bear OB'); }
    updateConfluenceUI('cfOB', nbo ? '✓ BULL' : nso ? '✓ BEAR' : '--', nbo ? 'var(--long)' : nso ? 'var(--short)' : 'var(--text-3)');

    // 5. MSS/BOS
    const rm = STATE.mssEvents.filter(m => candles.length - m.index < 20);
    const lm = rm[rm.length-1];
    if (lm) {
        if (lm.type === 'MSS_BULL') { ls += 2; reasons.long.push('MSS Bullish'); }
        if (lm.type === 'MSS_BEAR') { ss += 2; reasons.short.push('MSS Bearish'); }
    }
    const mssText = lm ? lm.type.replace('_',' ') : STATE.currentTrend.toUpperCase();
    const mssColor = (lm && lm.type.includes('BULL')) || STATE.currentTrend === 'bullish' ? 'var(--long)' : (lm && lm.type.includes('BEAR')) || STATE.currentTrend === 'bearish' ? 'var(--short)' : 'var(--text-3)';
    updateConfluenceUI('cfMSS', mssText, mssColor);

    // 6. CANDLE PATTERNS
    const patterns = detectCandlePatterns(candles);
    STATE.currentPattern = patterns;
    renderPatterns(patterns);
    
    let patternScore = 0;
    if (patterns) {
        patterns.forEach(p => {
            if (p.type === 'bull') { ls += p.strength; patternScore += p.strength; reasons.long.push(p.name); }
            else if (p.type === 'bear') { ss += p.strength; patternScore += p.strength; reasons.short.push(p.name); }
        });
    }
    updateConfluenceUI('cfPattern', patterns ? patterns.map(p => p.name).join(', ') : '--', patterns ? (patterns[0].type === 'bull' ? 'var(--long)' : patterns[0].type === 'bear' ? 'var(--short)' : 'var(--text-2)') : 'var(--text-3)');

    // 7. Wyckoff
    const wk = STATE.wyckoff;
    if (wk.combined === 'strong_bull') { ls += 2; reasons.long.push('WK MTF Bull'); }
    else if (wk.combined === 'strong_bear') { ss += 2; reasons.short.push('WK MTF Bear'); }
    else if (wk.combined === 'conflict') {
        warnings.long.push('WK MTF Conflict (-1)');
        warnings.short.push('WK MTF Conflict (-1)');
        ls -= 1;
        ss -= 1;
    }
    const wkText = wk.combined === 'strong_bull' ? '✓ ALIGN' : wk.combined === 'strong_bear' ? '✓ ALIGN' : wk.combined === 'conflict' ? '⚠ CONFLICT' : 'NEUTRAL';
    const wkColor = wk.combined.includes('bull') ? 'var(--long)' : wk.combined.includes('bear') ? 'var(--short)' : wk.combined === 'conflict' ? 'var(--warn)' : 'var(--text-3)';
    updateConfluenceUI('cfWyckoff', wkText, wkColor);

    // 8. Liq sweep
    const sweep = detectLiquiditySweep(candles);
    if (sweep === 'bull') { ls += 1.5; reasons.long.push('Liq Sweep'); }
    if (sweep === 'bear') { ss += 1.5; reasons.short.push('Liq Sweep'); }
    updateConfluenceUI('cfLiq', sweep ? sweep.toUpperCase()+' SWEEP' : '--', sweep === 'bull' ? 'var(--long)' : sweep === 'bear' ? 'var(--short)' : 'var(--text-3)');

    // 9. RSI Divergence
    const div = STATE.divergences[STATE.divergences.length - 1];
    if (div && candles.length - div.endIndex < 5) {
        if (div.type === 'bullish') { ls += 2; reasons.long.push('RSI Div'); }
        if (div.type === 'bearish') { ss += 2; reasons.short.push('RSI Div'); }
        updateConfluenceUI('cfRSI', `✓ ${div.type.toUpperCase()}`, div.type === 'bullish' ? 'var(--long)' : 'var(--short)');
    } else {
        updateConfluenceUI('cfRSI', '--', 'var(--text-3)');
    }

    // 10. Volume
    const avgV = candles.slice(-20).reduce((a,c)=>a+c.v,0)/20;
    const lastV = candles[candles.length-1].v, vc = lastV > avgV * 1.3;
    if (vc) { 
        if (candles[candles.length-1].c > candles[candles.length-1].o) { ls += 1; reasons.long.push('Vol ✓'); } 
        else { ss += 1; reasons.short.push('Vol ✓'); }
    }
    updateConfluenceUI('cfVol', vc ? `✓ ${(lastV/avgV).toFixed(1)}x` : `${(lastV/avgV).toFixed(1)}x`, vc ? 'var(--long)' : 'var(--text-3)');

    // 11. TREND ALIGNMENT
    let trendWarning = false;
    if (STATE.currentTrend === 'bullish' && ss > ls) {
        warnings.short.push('Against Trend (Bull) (-1.5)');
        ss -= 1.5;
        trendWarning = true;
    } else if (STATE.currentTrend === 'bearish' && ls > ss) {
        warnings.long.push('Against Trend (Bear) (-1.5)');
        ls -= 1.5;
        trendWarning = true;
    }
    
    const tb = STATE.currentTrend === 'bullish' ? 0.5 : STATE.currentTrend === 'bearish' ? -0.5 : 0;
    ls += Math.max(0, tb); 
    ss += Math.max(0, -tb);
    
    const trendText = trendWarning ? '⚠ ' + STATE.currentTrend.toUpperCase() : '✓ ' + STATE.currentTrend.toUpperCase();
    const trendColor = trendWarning ? 'var(--warn)' : STATE.currentTrend === 'bullish' ? 'var(--long)' : 'var(--short)';
    updateConfluenceUI('cfTrend', trendText, trendColor);

    // Decision with Categories
    const dir = ls > ss ? 'long' : 'short';
    let score = dir === 'long' ? ls : ss;
    let rl = dir === 'long' ? reasons.long : reasons.short;
    let wl = dir === 'long' ? warnings.long : warnings.short;
    
    // Kategorisierung
    let category = null;
    if (score >= 9.5 && rl.length >= 5) {
        category = 'safe';
    } else if (score >= 7.5 && rl.length >= 3) {
        category = 'neutral';
    } else if (score >= 5.0 && rl.length >= 2) {
        category = 'risky';
    }
    
    if (category) {
        const entry = price;
        const swings = STATE.swingPoints || [];
        let sl;
        const buffer = atrVal * 0.3;

        if (dir === 'long') {
            const candidates = swings
                .filter(s => s.type === 'low' && s.price < entry && s.price > entry - atrVal * 5)
                .sort((a, b) => b.price - a.price);
            sl = candidates.length > 0 ? candidates[0].price - buffer : entry - atrVal * 2.5;
        } else {
            const candidates = swings
                .filter(s => s.type === 'high' && s.price > entry && s.price < entry + atrVal * 5)
                .sort((a, b) => a.price - b.price);
            sl = candidates.length > 0 ? candidates[0].price + buffer : entry + atrVal * 2.5;
        }

        const slDist = Math.abs(entry - sl);
        const tp1 = dir === 'long' ? entry + slDist * 2 : entry - slDist * 2;
        const tp2 = dir === 'long' ? entry + slDist * 3.5 : entry - slDist * 3.5;
        const rr = Math.abs(tp1 - entry) / slDist;
        
        if (rr < 1.5) {
            renderNoSignal(score);
            return;
        }
        
        let quality = category === 'safe' ? 'A+' : category === 'neutral' ? 'A' : 'B';
        if (wl.length > 0 && quality === 'A+') quality = 'A';
        else if (wl.length > 0 && quality === 'A') quality = 'B';
        
        const sig = { 
            direction: dir, 
            entry, 
            sl, 
            tp1, 
            tp2, 
            rr, 
            quality, 
            category,
            score, 
            reasons: rl, 
            warnings: wl,
            time: Date.now(), 
            status: 'active',
            tf: STATE.currentTF,
            atr: atrVal,
            pattern: patterns ? patterns.map(p => p.name).join(', ') : null
        };
        
        STATE.activeSignal = sig;
        STATE.signalCooldown = Date.now() + STATE.COOLDOWN_MS;
        STATE.signalCount[category]++;
        renderActiveSignal(sig); 
        addSignalToHistory(sig);
        showToast(dir, quality, entry, sl, tp1, rl.join(', '), wl.length > 0, category);
        
        if ('Notification' in window && Notification.permission === 'granted') {
            new Notification(`${dir.toUpperCase()} ${category.toUpperCase()} SIGNAL (${quality})`, { 
                body: `Entry: $${entry.toFixed(0)} | SL: $${sl.toFixed(0)} | ${wl.length > 0 ? '⚠ With warnings' : ''}` 
            });
        }
    } else { 
        renderNoSignal(Math.max(ls, ss)); 
    }
}

function updateConfluenceUI(id, text, color) {
    safeSetText(id, text, color);
}

function detectLiquiditySweep(candles) {
    if (candles.length < 30) return null;
    const rec = candles.slice(-10), prev = candles.slice(-30, -10);
    if (prev.length < 10) return null;
    const pL = Math.min(...prev.map(c=>c.l)), pH = Math.max(...prev.map(c=>c.h));
    if (rec.some(c => c.l < pL) && rec[rec.length-1].c > pL) return 'bull';
    if (rec.some(c => c.h > pH) && rec[rec.length-1].c < pH) return 'bear';
    return null;
}

// ============================================================
// SIGNAL UI
// ============================================================
function renderActiveSignal(sig) {
    const hasWarnings = sig.warnings && sig.warnings.length > 0;
    const card = document.getElementById('activeSignalCard');
    if (card) {
        card.className = `signal-card active-${sig.direction} ${sig.category}`;
        card.onclick = () => openSignalModal(sig);
    }
    
    safeSetText('sigDirection', sig.direction.toUpperCase(), sig.direction === 'long' ? 'var(--long)' : 'var(--short)');
    
    const sq = document.getElementById('sigQuality');
    if (sq) {
        sq.textContent = sig.quality;
        sq.className = `signal-quality quality-${sig.category}`;
    }
    
    safeSetText('sigEntry', '$' + sig.entry.toFixed(0));
    safeSetText('sigSL', '$' + sig.sl.toFixed(0), 'var(--short)');
    safeSetText('sigTP1', '$' + sig.tp1.toFixed(0), 'var(--long)');
    safeSetText('sigTP2', '$' + sig.tp2.toFixed(0), 'var(--long)');
    safeSetText('sigRR', '1:' + sig.rr.toFixed(1), sig.rr >= 2 ? 'var(--long)' : sig.rr >= 1.5 ? 'var(--warn)' : 'var(--short)');
    safeSetText('sigCategory', sig.category.toUpperCase(), `var(--${sig.category})`);
    safeSetText('sigConf', sig.score.toFixed(1) + '/12');
    safeSetText('sigPattern', sig.pattern || '--', sig.pattern ? 'var(--accent)' : 'var(--text-3)');
    safeSetText('sigReason', sig.reasons.slice(0,3).join(', '), 'var(--text-1)');
    
    const warnEl = document.getElementById('sigWarning');
    if (warnEl) {
        if (hasWarnings) {
            warnEl.textContent = '⚠ ' + sig.warnings.join(', ');
            warnEl.style.display = 'block';
        } else {
            warnEl.style.display = 'none';
        }
    }
}

function renderNoSignal(score) {
    const card = document.getElementById('activeSignalCard');
    if (card) {
        card.className = 'signal-card';
        card.onclick = null;
    }
    
    safeSetText('sigDirection', t('signal_waiting'), 'var(--text-3)');
    
    const sq = document.getElementById('sigQuality');
    if (sq) {
        sq.textContent = score > 0 ? score.toFixed(0)+'/12' : '--';
        sq.className = 'signal-quality quality-none';
    }
    
    safeSetText('sigCategory', '--');
    safeSetText('sigPattern', '--', 'var(--text-3)');
    
    const warnEl = document.getElementById('sigWarning');
    if (warnEl) warnEl.style.display = 'none';
}

function updateCooldownBar() { 
    const r = STATE.signalCooldown - Date.now(); 
    const cf = document.getElementById('cooldownFill');
    if (cf) cf.style.width = Math.max(0, r/STATE.COOLDOWN_MS*100) + '%'; 
}

// ============================================================
// SIGNAL HISTORY WITH TABS & FILTER
// ============================================================
function setHistoryTab(tab) {
    STATE.historyTab = tab;
    const tabActive = document.getElementById('tabActive');
    const tabClosed = document.getElementById('tabClosed');
    if (tabActive) tabActive.classList.toggle('active', tab === 'active');
    if (tabClosed) tabClosed.classList.toggle('active', tab === 'closed');
    renderSignalHistory();
}

function setHistoryFilter(filter) {
    STATE.historyFilter = filter;
    document.querySelectorAll('.filter-chip').forEach(btn => btn.classList.remove('active'));
    const filterBtn = document.getElementById('filter' + filter.charAt(0).toUpperCase() + filter.slice(1));
    if (filterBtn) filterBtn.classList.add('active');
    renderSignalHistory();
}

function addSignalToHistory(sig) { 
    STATE.signalHistory.unshift(sig); 
    renderSignalHistory(); 
    updateSessionStats();
}

function renderSignalHistory() {
    const el = document.getElementById('signalHistory'); 
    if (!el) return;
    
    let filtered = STATE.signalHistory;
    
    if (STATE.historyTab === 'active') {
        filtered = filtered.filter(s => s.status === 'active');
    } else {
        filtered = filtered.filter(s => ['tp1','tp2','sl','expired'].includes(s.status));
    }
    
    if (STATE.historyFilter === 'long') filtered = filtered.filter(s => s.direction === 'long');
    if (STATE.historyFilter === 'short') filtered = filtered.filter(s => s.direction === 'short');
    if (STATE.historyFilter === 'risky') filtered = filtered.filter(s => s.category === 'risky');
    if (STATE.historyFilter === 'safe') filtered = filtered.filter(s => s.category === 'safe');
    
    if (!filtered.length) { 
        el.innerHTML = `<div style="text-align:center;color:var(--text-3);padding:12px;font-size:10px;">${t('signal_no_signal')}</div>`; 
        return; 
    }
    
    const visible = filtered.slice(0, 20);
    
    el.innerHTML = visible.map((sig) => {
        const time = new Date(sig.time).toLocaleTimeString(CURRENT_LANG === 'de' ? 'de-DE' : 'en-US',{hour:'2-digit',minute:'2-digit'});
        const dc = sig.direction === 'long' ? 'var(--long)' : 'var(--short)';
        let rt = t('status_active'), rc = 'var(--warn)';
        if (sig.status === 'tp1') { rt = t('status_tp1'); rc = 'var(--long)'; }
        else if (sig.status === 'tp2') { rt = t('status_tp2'); rc = 'var(--long)'; }
        else if (sig.status === 'sl') { rt = t('status_sl'); rc = 'var(--short)'; }
        else if (sig.status === 'expired') { rt = t('status_expired'); rc = 'var(--text-3)'; }
        
        const hasWarn = sig.warnings && sig.warnings.length > 0;
        
        return `<div class="history-item ${sig.category} ${hasWarn ? 'warning' : ''}" onclick="openSignalModalByTime(${sig.time})">
            <span style="color:${dc};font-weight:700">${sig.direction.toUpperCase().slice(0,4)}${hasWarn ? ' ⚠' : ''}</span>
            <span style="color:var(--text-2)">$${sig.entry.toFixed(0)} | ${sig.quality}</span>
            <span style="color:${rc};font-weight:600;text-align:right">${rt}</span>
            <span style="color:var(--text-3);text-align:right">${time}</span>
        </div>`;
    }).join('');
}

function openSignalModalByTime(time) {
    const sig = STATE.signalHistory.find(s => s.time === time);
    if (sig) openSignalModal(sig);
}

function openSignalModal(sig) {
    if (!sig) return;
    
    const modal = document.getElementById('signalModal');
    const title = document.getElementById('modalTitle');
    const body = document.getElementById('modalBody');
    
    if (!modal || !title || !body) return;
    
    const dirColor = sig.direction === 'long' ? 'var(--long)' : 'var(--short)';
    const statusMap = {
        'active': t('status_active'),
        'tp1': t('status_tp1'),
        'tp2': t('status_tp2'),
        'sl': t('status_sl'),
        'expired': t('status_expired')
    };
    const statusText = statusMap[sig.status] || sig.status;
    
    let pnlHtml = '';
    if (sig.status === 'active') {
        const currentPnL = sig.direction === 'long' ? 
            ((STATE.price - sig.entry) / (sig.entry - sig.sl)).toFixed(2) :
            ((sig.entry - STATE.price) / (sig.sl - sig.entry)).toFixed(2);
        const pnlColor = parseFloat(currentPnL) >= 0 ? 'pnl-positive' : 'pnl-negative';
        pnlHtml = `<div class="modal-row"><span class="modal-label">Current R</span><span class="modal-value ${pnlColor}">${currentPnL}R</span></div>`;
    } else {
        const exitPrice = sig.status === 'tp1' ? sig.tp1 : sig.status === 'tp2' ? sig.tp2 : sig.status === 'sl' ? sig.sl : sig.entry;
        const pnl = sig.direction === 'long' ? 
            ((exitPrice - sig.entry) / (sig.entry - sig.sl)).toFixed(2) :
            ((sig.entry - exitPrice) / (sig.sl - sig.entry)).toFixed(2);
        const pnlColor = parseFloat(pnl) >= 0 ? 'pnl-positive' : 'pnl-negative';
        pnlHtml = `<div class="modal-row"><span class="modal-label">Result</span><span class="modal-value ${pnlColor}">${pnl}R</span></div>`;
    }
    
    const hasWarn = sig.warnings && sig.warnings.length > 0;
    const warnHtml = hasWarn ? `<div class="modal-section" style="border:1px solid var(--warn);border-radius:4px;padding:10px;background:rgba(255,193,7,0.05)">
        <div class="modal-section-title" style="color:var(--warn)">⚠ Warnings</div>
        ${sig.warnings.map(w => `<div class="modal-row" style="color:var(--warn)"><span class="modal-label">•</span><span class="modal-value">${w}</span></div>`).join('')}
    </div>` : '';
    
    const catColor = sig.category === 'risky' ? 'var(--risky)' : sig.category === 'neutral' ? 'var(--neutral)' : 'var(--safe)';
    
    title.innerHTML = `<span style="color:${dirColor}">${sig.direction.toUpperCase()} ${sig.category.toUpperCase()} (${sig.quality})</span>`;
    title.innerHTML += `<span style="font-size:9px;color:var(--text-3);margin-left:12px">${statusText}</span>`;
    
    body.innerHTML = `
        <div class="modal-section">
            <div class="modal-section-title">Trade Details</div>
            <div class="modal-row"><span class="modal-label">Category</span><span class="modal-value" style="color:${catColor}">${sig.category.toUpperCase()}</span></div>
            <div class="modal-row"><span class="modal-label">Entry</span><span class="modal-value">$${sig.entry.toFixed(2)}</span></div>
            <div class="modal-row"><span class="modal-label">Stop Loss</span><span class="modal-value" style="color:var(--short)">$${sig.sl.toFixed(2)}</span></div>
            <div class="modal-row"><span class="modal-label">Take Profit 1</span><span class="modal-value" style="color:var(--long)">$${sig.tp1.toFixed(2)}</span></div>
            <div class="modal-row"><span class="modal-label">Take Profit 2</span><span class="modal-value" style="color:var(--long)">$${sig.tp2.toFixed(2)}</span></div>
            <div class="modal-row"><span class="modal-label">R:R Ratio</span><span class="modal-value">1:${sig.rr.toFixed(2)}</span></div>
            <div class="modal-row"><span class="modal-label">Candle Pattern</span><span class="modal-value" style="color:var(--accent)">${sig.pattern || '--'}</span></div>
            ${pnlHtml}
        </div>
        
        <div class="modal-section">
            <div class="modal-section-title">Confluence (${sig.score.toFixed(1)} Points)</div>
            ${sig.reasons.map(r => `<div class="modal-row"><span class="modal-label">✓</span><span class="modal-value">${r}</span></div>`).join('')}
        </div>
        
        ${warnHtml}
        
        <div class="modal-section">
            <div class="modal-section-title">Metadata</div>
            <div class="modal-row"><span class="modal-label">Timeframe</span><span class="modal-value">${sig.tf || STATE.currentTF}</span></div>
            <div class="modal-row"><span class="modal-label">Time</span><span class="modal-value">${new Date(sig.time).toLocaleString(CURRENT_LANG === 'de' ? 'de-DE' : 'en-US')}</span></div>
            <div class="modal-row"><span class="modal-label">ATR</span><span class="modal-value">$${sig.atr ? sig.atr.toFixed(2) : '--'}</span></div>
        </div>
    `;
    
    modal.classList.add('active');
}

function closeModal() {
    const modal = document.getElementById('signalModal');
    if (modal) modal.classList.remove('active');
}

function trackSignalOutcomes() {
    let changed = false;
    STATE.signalHistory.forEach(sig => {
        if (sig.status !== 'active') return;
        if (Date.now() - sig.time > 24*60*60*1000) { sig.status = 'expired'; changed = true; return; }
        const prev = sig.status;
        if (sig.direction === 'long') {
            if (STATE.price <= sig.sl) sig.status = 'sl';
            else if (STATE.price >= sig.tp2) sig.status = 'tp2';
            else if (STATE.price >= sig.tp1) sig.status = 'tp1';
        } else {
            if (STATE.price >= sig.sl) sig.status = 'sl';
            else if (STATE.price <= sig.tp2) sig.status = 'tp2';
            else if (STATE.price <= sig.tp1) sig.status = 'tp1';
        }
        if (sig.status !== prev) {
            changed = true;
            const isWin = sig.status !== 'sl';
            const label = sig.status === 'tp2' ? 'TP2 HIT ✓ +3.5R' : sig.status === 'tp1' ? 'TP1 HIT ✓ +2R' : 'STOP LOSS ✗ -1R';
            const col = isWin ? 'var(--long)' : 'var(--short)';
            const t = document.createElement('div');
            t.className = `toast ${isWin ? 'long-toast' : 'short-toast'}`;
            t.innerHTML = `<div class="toast-title" style="color:${col}">${sig.direction.toUpperCase()} ${label}</div><div class="toast-body">Entry $${sig.entry.toFixed(0)} | Exit ~$${STATE.price.toFixed(0)}${sig.warnings && sig.warnings.length > 0 ? '<br>⚠ Had warnings' : ''}</div><div class="toast-time">${new Date().toLocaleTimeString(CURRENT_LANG === 'de' ? 'de-DE' : 'en-US',{hour:'2-digit',minute:'2-digit'})}</div>`;
            document.getElementById('toastContainer').appendChild(t);
            setTimeout(() => { t.style.opacity='0'; setTimeout(()=>t.remove(),300); }, 8000);
        }
    });
    if (changed) { renderSignalHistory(); updateSessionStats(); }
}

function showToast(dir, quality, entry, sl, tp1, reasons, hasWarning, category) {
    const c = document.getElementById('toastContainer');
    if (!c) return;
    
    const t = document.createElement('div');
    const catColor = category === 'risky' ? 'var(--risky)' : category === 'neutral' ? 'var(--neutral)' : 'var(--safe)';
    t.className = `toast ${dir === 'long' ? 'long-toast' : 'short-toast'} ${hasWarning ? 'warn-toast' : ''}`;
    t.innerHTML = `<div class="toast-title" style="color:${dir === 'long' ? 'var(--long)' : 'var(--short)'}">${dir.toUpperCase()} ${category.toUpperCase()} (${quality})${hasWarning ? ' ⚠' : ''}</div><div class="toast-body">Entry: $${entry.toFixed(0)} | SL: $${sl.toFixed(0)} | TP: $${tp1.toFixed(0)}<br>${reasons}</div><div class="toast-time">${new Date().toLocaleTimeString(CURRENT_LANG === 'de' ? 'de-DE' : 'en-US',{hour:'2-digit',minute:'2-digit',second:'2-digit'})}</div>`;
    c.appendChild(t);
    setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), 300); }, 12000);
}

// ============================================================
// CHART STATE MANAGEMENT (PERSIST ZOOM)
// ============================================================
function saveChartState() {
    if (!STATE.chart) return;
    try {
        const xScale = STATE.chart.scales.x;
        const yScale = STATE.chart.scales.y;
        if (xScale && yScale) {
            STATE.chartState = {
                min: xScale.min,
                max: xScale.max,
                yMin: yScale.min,
                yMax: yScale.max
            };
        }
    } catch(e) {}
}

function restoreChartState() {
    if (!STATE.chart || !STATE.chartState) return;
    try {
        STATE.chart.scales.x.options.min = STATE.chartState.min;
        STATE.chart.scales.x.options.max = STATE.chartState.max;
        STATE.chart.scales.y.options.min = STATE.chartState.yMin;
        STATE.chart.scales.y.options.max = STATE.chartState.yMax;
    } catch(e) {}
}

// ============================================================
// CHARTS & ANNOTATIONS
// ============================================================
function getTimeUnit(tf) {
    if (tf.includes('m')) return 'minute';
    if (tf.includes('h') || tf.includes('H')) return 'hour';
    if (tf.includes('d') || tf.includes('D')) return 'day';
    return 'hour';
}

function getTimeFormat(tf) {
    if (tf === '1m' || tf === '3m' || tf === '5m') return { minute: 'HH:mm' };
    if (tf === '15m' || tf === '30m') return { hour: 'HH:mm' };
    if (tf === '1h' || tf === '2h' || tf === '4h') return { day: 'dd.MM', hour: 'dd. HH:mm' };
    return { day: 'dd.MM' };
}

function syncCharts(sourceChart) {
    if (STATE.isSyncing) return;
    STATE.isSyncing = true;
    
    const charts = [STATE.chart, STATE.volumeChart, STATE.rsiChart].filter(c => c && c !== sourceChart);
    
    charts.forEach(targetChart => {
        try {
            const xScale = sourceChart.scales.x;
            targetChart.scales.x.options.min = xScale.min;
            targetChart.scales.x.options.max = xScale.max;
            targetChart.update('none');
        } catch(e) {}
    });
    
    setTimeout(() => { STATE.isSyncing = false; }, 10);
}

function buildAnnotations() {
    const candles = STATE.tfData[STATE.currentTF];
    if (!candles || !candles.length) return {};
    const annotations = {};
    let aid = 0;

    if (STATE.overlays.fvg) {
        STATE.fvgs.filter(f => f.status !== 'filled').slice(-6).forEach(f => {
            annotations['fvg' + aid++] = {
                type: 'box',
                yMin: f.bottom,
                yMax: f.top,
                xMin: f.time,
                backgroundColor: f.type === 'bullish' ? 'rgba(0,230,118,0.08)' : 'rgba(255,23,68,0.08)',
                borderColor: f.type === 'bullish' ? 'rgba(0,230,118,0.4)' : 'rgba(255,23,68,0.4)',
                borderWidth: 1,
                borderDash: [3, 3]
            };
        });
    }

    if (STATE.overlays.fib && STATE.fibLevels.levels[618]) {
        const fibColors = {
            0: 'rgba(255,255,255,0.3)',
            382: 'rgba(255,193,7,0.4)',
            50: 'rgba(160,168,184,0.4)',
            618: 'rgba(0,230,118,0.4)',
            786: 'rgba(255,23,68,0.4)',
            100: 'rgba(255,255,255,0.3)'
        };
        
        Object.entries(STATE.fibLevels.levels).forEach(([level, price]) => {
            annotations['fib' + aid++] = {
                type: 'line',
                yMin: price,
                yMax: price,
                borderColor: fibColors[level] || 'rgba(128,128,128,0.3)',
                borderWidth: level === '0' || level === '100' ? 1 : 1.5,
                borderDash: [5, 5],
                label: {
                    display: true,
                    content: level === '0' ? '0%' : level === '100' ? '100%' : level + '%',
                    position: 'end',
                    font: { size: 8, family: 'JetBrains Mono' },
                    color: fibColors[level] || '#888',
                    backgroundColor: 'rgba(6,8,10,0.8)',
                    padding: { top: 2, bottom: 2, left: 4, right: 4 }
                }
            };
        });
    }

    if (STATE.overlays.ob) {
        STATE.orderBlocks.slice(-4).forEach(ob => {
            annotations['ob' + aid++] = {
                type: 'box',
                yMin: ob.low,
                yMax: ob.high,
                xMin: ob.time,
                backgroundColor: ob.type === 'bullish' ? 'rgba(68,138,255,0.06)' : 'rgba(255,138,68,0.06)',
                borderColor: ob.type === 'bullish' ? 'rgba(68,138,255,0.3)' : 'rgba(255,138,68,0.3)',
                borderWidth: 1,
                label: {
                    display: true,
                    content: ob.type === 'bullish' ? 'OB ↑' : 'OB ↓',
                    position: 'start',
                    font: { size: 8, family: 'JetBrains Mono' },
                    color: ob.type === 'bullish' ? 'rgba(68,138,255,0.7)' : 'rgba(255,138,68,0.7)',
                    backgroundColor: 'transparent'
                }
            };
        });
    }

    if (STATE.overlays.mss) {
        [...STATE.mssEvents.slice(-6), ...STATE.bosEvents.slice(-6)].forEach(ev => {
            const isMSS = ev.type.startsWith('MSS');
            const isBull = ev.type.includes('BULL');
            annotations['mss' + aid++] = {
                type: 'line',
                yMin: ev.price,
                yMax: ev.price,
                xMin: ev.time,
                borderColor: isMSS ? (isBull ? 'rgba(224,64,251,0.7)' : 'rgba(224,64,251,0.5)') : (isBull ? 'rgba(0,230,118,0.4)' : 'rgba(255,23,68,0.4)'),
                borderWidth: isMSS ? 2 : 1,
                borderDash: isMSS ? [] : [6, 4],
                label: {
                    display: true,
                    content: ev.type.replace('_', ' '),
                    position: 'start',
                    font: { size: 8, family: 'JetBrains Mono', weight: isMSS ? '700' : '400' },
                    color: isMSS ? '#e040fb' : (isBull ? 'rgba(0,230,118,0.7)' : 'rgba(255,23,68,0.7)'),
                    backgroundColor: 'rgba(6,8,10,0.8)',
                    padding: { top: 2, bottom: 2, left: 4, right: 4 }
                }
            };
        });
    }

    if (STATE.overlays.liq) {
        STATE.liquidityLevels.slice(0, 4).forEach(l => {
            annotations['liq' + aid++] = {
                type: 'line',
                yMin: l.price,
                yMax: l.price,
                borderColor: 'rgba(255,193,7,0.35)',
                borderWidth: 1,
                borderDash: [8, 4],
                label: {
                    display: true,
                    content: `${l.type} $${l.price.toFixed(0)}`,
                    position: 'end',
                    font: { size: 8, family: 'JetBrains Mono' },
                    color: 'rgba(255,193,7,0.7)',
                    backgroundColor: 'rgba(6,8,10,0.8)',
                    padding: { top: 2, bottom: 2, left: 4, right: 4 }
                }
            };
        });
    }

    return annotations;
}

function initChart() {
    saveChartState();
    
    if (STATE.chart) { STATE.chart.destroy(); STATE.chart = null; }
    const ctx = document.getElementById('mainChart').getContext('2d');
    const candles = STATE.tfData[STATE.currentTF];
    if (!candles || !candles.length) return;

    const closes = candles.map(c => c.c);
    const ema20 = calcEMA(closes, 20), ema50 = calcEMA(closes, 50), ema100 = calcEMA(closes, 100), ema200 = calcEMA(closes, 200);
    const showEma = STATE.overlays.ema;

    const datasets = [];

    if (STATE.chartType === 'candles') {
        datasets.push({
            label: 'BTC',
            data: candles.map(c => ({ x: c.t, o: c.o, h: c.h, l: c.l, c: c.c })),
            type: 'candlestick',
            color: { up: '#00e676', down: '#ff1744', unchanged: '#6b7588' },
            borderColor: { up: '#00e676', down: '#ff1744', unchanged: '#6b7588' },
            order: 0
        });
    } else {
        datasets.push({
            label: 'BTC',
            data: closes.map((c, i) => ({ x: candles[i].t, y: c })),
            type: 'line',
            borderColor: '#e8ecf1',
            borderWidth: 1.5,
            pointRadius: 0,
            fill: false,
            tension: 0,
            order: 0
        });
    }

    if (showEma) {
        datasets.push(
            { label: 'EMA 20', data: ema20.map((v, i) => ({ x: candles[i].t, y: v })), type: 'line', borderColor: 'rgba(0,230,118,0.8)', borderWidth: 1.5, pointRadius: 0, fill: false, order: 1 },
            { label: 'EMA 50', data: ema50.map((v, i) => ({ x: candles[i].t, y: v })), type: 'line', borderColor: 'rgba(255,193,7,0.9)', borderWidth: 2, pointRadius: 0, fill: false, order: 2 },
            { label: 'EMA 100', data: ema100.map((v, i) => ({ x: candles[i].t, y: v })), type: 'line', borderColor: 'rgba(255,23,68,0.7)', borderWidth: 1.5, pointRadius: 0, borderDash: [5,5], fill: false, order: 3 },
            { label: 'EMA 200', data: ema200.map((v, i) => ({ x: candles[i].t, y: v })), type: 'line', borderColor: 'rgba(68,138,255,0.9)', borderWidth: 2, pointRadius: 0, fill: false, order: 4 }
        );
    }

    const timeUnit = getTimeUnit(STATE.currentTF);
    const timeFormats = getTimeFormat(STATE.currentTF);

    STATE.chart = new Chart(ctx, {
        type: STATE.chartType === 'candles' ? 'candlestick' : 'line',
        data: { datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            interaction: { intersect: false, mode: 'index' },
            plugins: {
                legend: {
                    display: showEma,
                    labels: { color: '#a0a8b8', font: { family: 'JetBrains Mono', size: 9 }, usePointStyle: true, pointStyle: 'line', boxWidth: 20 },
                    position: 'top', align: 'end'
                },
                tooltip: {
                    backgroundColor: 'rgba(12,15,19,0.95)', titleColor: '#e8ecf1', bodyColor: '#a0a8b8',
                    borderColor: '#2a3140', borderWidth: 1,
                    titleFont: { family: 'JetBrains Mono', size: 10 }, bodyFont: { family: 'JetBrains Mono', size: 9 }, padding: 8,
                    callbacks: {
                        title: function(context) {
                            const date = new Date(context[0].parsed.x);
                            return date.toLocaleString(CURRENT_LANG === 'de' ? 'de-DE' : 'en-US');
                        },
                        label: function(ctx) {
                            if (ctx.dataset.label === 'BTC' && STATE.chartType === 'candles' && ctx.raw && ctx.raw.o !== undefined) {
                                const d = ctx.raw; return `O: $${d.o.toFixed(0)} H: $${d.h.toFixed(0)} L: $${d.l.toFixed(0)} C: $${d.c.toFixed(0)}`;
                            }
                            return `${ctx.dataset.label}: $${ctx.parsed.y?.toLocaleString() || ''}`;
                        }
                    }
                },
                annotation: { annotations: buildAnnotations() },
                zoom: {
                    pan: { enabled: false },
                    zoom: {
                        wheel: { enabled: true, speed: 0.08 },
                        pinch: { enabled: true },
                        drag: { enabled: false },
                        mode: 'xy',
                        onZoom: ({chart}) => syncCharts(chart)
                    },
                    limits: {}
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: timeUnit, displayFormats: timeFormats, tooltipFormat: 'dd.MM.yyyy HH:mm' },
                    grid: { color: 'rgba(30,37,48,0.5)' },
                    ticks: { color: '#444e5f', font: { family: 'JetBrains Mono', size: 9 }, maxRotation: 0, autoSkip: true, maxTicksLimit: 8 }
                },
                y: {
                    position: 'right',
                    grid: { color: 'rgba(30,37,48,0.5)' },
                    ticks: { color: '#444e5f', font: { family: 'JetBrains Mono', size: 9 }, callback: v => '$' + v.toLocaleString() }
                }
            }
        }
    });
    
    restoreChartState();
    
    document.getElementById('mainChart').addEventListener('dblclick', () => {
        if (STATE.chart) STATE.chart.resetZoom();
        if (STATE.volumeChart) STATE.volumeChart.resetZoom();
        if (STATE.rsiChart) STATE.rsiChart.resetZoom();
    });
    setupChartInteraction();
    initVolumeChart();
    if (STATE.overlays.rsi) initRSIChart();
}

function initVolumeChart() {
    if (STATE.volumeChart) { STATE.volumeChart.destroy(); STATE.volumeChart = null; }
    const ctx = document.getElementById('volumeChart').getContext('2d');
    const candles = STATE.tfData[STATE.currentTF];
    if (!candles || !candles.length) return;
    
    const timeUnit = getTimeUnit(STATE.currentTF);
    
    STATE.volumeChart = new Chart(ctx, {
        type: 'bar',
        data: {
            datasets: [{
                label: 'Volume',
                data: candles.map(c => ({
                    x: c.t,
                    y: c.v,
                    backgroundColor: c.c >= c.o ? 'rgba(0, 230, 118, 0.5)' : 'rgba(255, 23, 68, 0.5)'
                })),
                backgroundColor: ctx => {
                    const raw = ctx.raw;
                    return raw?.backgroundColor || 'rgba(128,128,128,0.3)';
                },
                borderWidth: 0,
                barPercentage: 0.7,
                categoryPercentage: 0.9
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            interaction: { intersect: false, mode: 'index' },
            plugins: {
                legend: { display: false },
                tooltip: {
                    backgroundColor: 'rgba(12,15,19,0.95)',
                    titleColor: '#e8ecf1',
                    bodyColor: '#a0a8b8',
                    borderColor: '#2a3140',
                    borderWidth: 1,
                    callbacks: {
                        title: ctx => {
                            const date = new Date(ctx[0].parsed.x);
                            return date.toLocaleString(CURRENT_LANG === 'de' ? 'de-DE' : 'en-US');
                        },
                        label: ctx => {
                            const val = ctx.raw.y;
                            return `Volume: ${val >= 1000000 ? (val/1000000).toFixed(2) + 'M' : (val/1000).toFixed(1) + 'k'}`;
                        }
                    }
                },
                zoom: {
                    pan: { enabled: false },
                    zoom: {
                        wheel: { enabled: false },
                        pinch: { enabled: false }
                    }
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: timeUnit },
                    grid: { display: false, drawBorder: false },
                    ticks: { display: false },
                    min: STATE.chart ? STATE.chart.scales.x.min : undefined,
                    max: STATE.chart ? STATE.chart.scales.x.max : undefined
                },
                y: {
                    position: 'right',
                    grid: { color: 'rgba(30,37,48,0.2)', drawBorder: false },
                    ticks: { 
                        color: '#444e5f', 
                        font: { size: 8, family: 'JetBrains Mono' },
                        maxTicksLimit: 3,
                        callback: v => v >= 1000000 ? (v/1000000).toFixed(0)+'M' : (v/1000).toFixed(0)+'k'
                    }
                }
            }
        }
    });
}

function initRSIChart() {
    if (STATE.rsiChart) { STATE.rsiChart.destroy(); STATE.rsiChart = null; }
    
    const container = document.getElementById('rsiContainer');
    if (container) container.style.display = 'block';
    
    const ctx = document.getElementById('rsiChart').getContext('2d');
    const candles = STATE.tfData[STATE.currentTF];
    if (!candles || !candles.length || STATE.rsiData.length === 0) return;
    
    const timeUnit = getTimeUnit(STATE.currentTF);
    
    // Update RSI Panel
    const lastRSI = STATE.rsiData[STATE.rsiData.length - 1];
    const lastK = STATE.stochRsiData.k[STATE.stochRsiData.k.length - 1];
    const lastD = STATE.stochRsiData.d[STATE.stochRsiData.d.length - 1];
    
    safeSetText('rsiValue', lastRSI ? lastRSI.toFixed(1) : '--', lastRSI > 70 ? 'var(--short)' : lastRSI < 30 ? 'var(--long)' : null);
    safeSetText('stochKValue', lastK ? lastK.toFixed(1) : '--');
    safeSetText('stochDValue', lastD ? lastD.toFixed(1) : '--');
    
    const divValueEl = document.getElementById('divergenceValue');
    const divListEl = document.getElementById('divergenceList');
    
    if (divValueEl && divListEl) {
        if (STATE.divergences.length > 0) {
            const lastDiv = STATE.divergences[STATE.divergences.length - 1];
            const isRecent = candles.length - lastDiv.endIndex < 10;
            divValueEl.textContent = lastDiv.type.toUpperCase();
            divValueEl.style.color = lastDiv.type === 'bullish' ? 'var(--long)' : 'var(--short)';
            
            if (isRecent) {
                divListEl.innerHTML = `<span class="divergence-tag">${lastDiv.type} @ candle ${lastDiv.endIndex}</span>`;
            } else {
                divListEl.innerHTML = '';
            }
        } else {
            divValueEl.textContent = '--';
            divValueEl.style.color = 'var(--text-3)';
            divListEl.innerHTML = '';
        }
    }
    
    STATE.rsiChart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [
                {
                    label: 'RSI',
                    data: candles.map((c, i) => ({ x: c.t, y: STATE.rsiData[i] })).filter(d => d.y !== null),
                    borderColor: '#00bcd4',
                    borderWidth: 1.5,
                    pointRadius: 0,
                    tension: 0.1,
                    yAxisID: 'y'
                },
                {
                    label: 'StochRSI %K',
                    data: candles.map((c, i) => ({ x: c.t, y: STATE.stochRsiData.k[i] })).filter(d => d.y !== null),
                    borderColor: '#ff9800',
                    borderWidth: 1,
                    pointRadius: 0,
                    borderDash: [3, 3],
                    yAxisID: 'y',
                    hidden: false
                },
                {
                    label: 'StochRSI %D',
                    data: candles.map((c, i) => ({ x: c.t, y: STATE.stochRsiData.d[i] })).filter(d => d.y !== null),
                    borderColor: '#e91e63',
                    borderWidth: 1,
                    pointRadius: 0,
                    borderDash: [2, 2],
                    yAxisID: 'y',
                    hidden: false
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            interaction: { intersect: false, mode: 'index' },
            plugins: {
                legend: { 
                    display: true,
                    labels: { color: '#a0a8b8', font: { size: 8 }, boxWidth: 8 }
                },
                annotation: {
                    annotations: {
                        overbought: {
                            type: 'line',
                            yMin: 70,
                            yMax: 70,
                            borderColor: 'rgba(255,23,68,0.3)',
                            borderWidth: 1,
                            borderDash: [4, 4]
                        },
                        oversold: {
                            type: 'line',
                            yMin: 30,
                            yMax: 30,
                            borderColor: 'rgba(0,230,118,0.3)',
                            borderWidth: 1,
                            borderDash: [4, 4]
                        }
                    }
                },
                zoom: {
                    pan: { enabled: false },
                    zoom: {
                        wheel: { enabled: false }
                    }
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: timeUnit },
                    grid: { display: false, drawBorder: false },
                    ticks: { display: false },
                    min: STATE.chart ? STATE.chart.scales.x.min : undefined,
                    max: STATE.chart ? STATE.chart.scales.x.max : undefined
                },
                y: {
                    position: 'right',
                    min: 0,
                    max: 100,
                    grid: { color: 'rgba(30,37,48,0.2)', drawBorder: false },
                    ticks: { 
                        color: '#444e5f', 
                        font: { size: 8 },
                        maxTicksLimit: 3,
                        callback: v => v.toFixed(0)
                    }
                }
            }
        }
    });
}

function setupChartInteraction() {
    const canvas = document.getElementById('mainChart');
    if (!canvas || canvas._tvInteractionActive) return;
    canvas._tvInteractionActive = true;

    let isDragging = false, dragMode = null;
    let startX, startY, startXMin, startXMax, startYMin, startYMax;

    function getChartArea() { return STATE.chart ? STATE.chart.chartArea : null; }
    function getScales() { return STATE.chart ? { x: STATE.chart.scales.x, y: STATE.chart.scales.y } : null; }

    function getDragMode(ex, ey) {
        const ca = getChartArea(); if (!ca) return null;
        const rect = canvas.getBoundingClientRect();
        const x = ex - rect.left, y = ey - rect.top;
        if (x > ca.right && y >= ca.top && y <= ca.bottom) return 'yscale';
        if (y > ca.bottom && x >= ca.left && x <= ca.right) return 'xscale';
        if (x >= ca.left && x <= ca.right && y >= ca.top && y <= ca.bottom) return 'pan';
        return null;
    }

    canvas.addEventListener('mousedown', (e) => {
        if (e.button !== 0 || !STATE.chart) return;
        const mode = getDragMode(e.clientX, e.clientY); if (!mode) return;
        isDragging = true; dragMode = mode;
        startX = e.clientX; startY = e.clientY;
        const { x, y } = getScales();
        startXMin = x.min; startXMax = x.max; startYMin = y.min; startYMax = y.max;
        canvas.style.cursor = mode === 'pan' ? 'grabbing' : mode === 'yscale' ? 'ns-resize' : 'ew-resize';
        e.preventDefault();
    });

    window.addEventListener('mousemove', (e) => {
        if (!isDragging || !STATE.chart) return;
        const dx = e.clientX - startX, dy = e.clientY - startY;
        const ca = getChartArea();
        if (!ca) return;
        const { x: xScale, y: yScale } = getScales();
        const xRange = startXMax - startXMin, yRange = startYMax - startYMin;
        const pxW = ca.right - ca.left, pxH = ca.bottom - ca.top;

        if (dragMode === 'pan') {
            xScale.options.min = startXMin - (dx / pxW) * xRange;
            xScale.options.max = startXMax - (dx / pxW) * xRange;
            yScale.options.min = startYMin + (dy / pxH) * yRange;
            yScale.options.max = startYMax + (dy / pxH) * yRange;
        } else if (dragMode === 'xscale') {
            const factor = Math.pow(1.005, -dx);
            const xCenter = (startXMin + startXMax) / 2;
            const newRange = xRange * factor;
            xScale.options.min = xCenter - newRange / 2;
            xScale.options.max = xCenter + newRange / 2;
        } else if (dragMode === 'yscale') {
            const factor = Math.pow(1.005, dy);
            const yCenter = (startYMin + startYMax) / 2;
            const newRange = yRange * factor;
            yScale.options.min = yCenter - newRange / 2;
            yScale.options.max = yCenter + newRange / 2;
        }
        STATE.chart.update('none');
        syncCharts(STATE.chart);
    });

    window.addEventListener('mouseup', () => {
        if (!isDragging) return;
        isDragging = false; dragMode = null;
        canvas.style.cursor = 'crosshair';
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isDragging || !STATE.chart) return;
        const mode = getDragMode(e.clientX, e.clientY);
        canvas.style.cursor = mode === 'pan' ? 'grab' : mode === 'yscale' ? 'ns-resize' : mode === 'xscale' ? 'ew-resize' : 'default';
    });

    canvas.addEventListener('mouseleave', () => { if (!isDragging) canvas.style.cursor = 'crosshair'; });
}

(function() {
    if (window._keyZoomAttached) return;
    window._keyZoomAttached = true;
    document.addEventListener('keydown', (e) => {
        if (!STATE.chart) return;
        if (['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;
        if (e.key === '+' || e.key === '=') { 
            e.preventDefault(); 
            STATE.chart.zoom(1.15); 
            syncCharts(STATE.chart);
        }
        else if (e.key === '-') { 
            e.preventDefault(); 
            STATE.chart.zoom(0.87); 
            syncCharts(STATE.chart);
        }
    });
})();

function updateChart() {
    if (!STATE.chart) return;
    const candles = STATE.tfData[STATE.currentTF];
    if (!candles || !candles.length) return;

    const closes = candles.map(c => c.c);

    if (STATE.chartType === 'candles') {
        STATE.chart.data.datasets[0].data = candles.map(c => ({ x: c.t, o: c.o, h: c.h, l: c.l, c: c.c }));
    } else {
        STATE.chart.data.datasets[0].data = closes.map((c, i) => ({ x: candles[i].t, y: c }));
    }

    if (STATE.overlays.ema && STATE.chart.data.datasets.length > 1) {
        const ema20 = calcEMA(closes, 20), ema50 = calcEMA(closes, 50), ema100 = calcEMA(closes, 100), ema200 = calcEMA(closes, 200);
        STATE.chart.data.datasets[1].data = ema20.map((v, i) => ({ x: candles[i].t, y: v }));
        STATE.chart.data.datasets[2].data = ema50.map((v, i) => ({ x: candles[i].t, y: v }));
        STATE.chart.data.datasets[3].data = ema100.map((v, i) => ({ x: candles[i].t, y: v }));
        STATE.chart.data.datasets[4].data = ema200.map((v, i) => ({ x: candles[i].t, y: v }));
    }

    STATE.chart.options.plugins.annotation.annotations = buildAnnotations();
    STATE.chart.update('none');
    
    if (STATE.volumeChart) {
        STATE.volumeChart.data.datasets[0].data = candles.map(c => ({
            x: c.t,
            y: c.v,
            backgroundColor: c.c >= c.o ? 'rgba(0, 230, 118, 0.5)' : 'rgba(255, 23, 68, 0.5)'
        }));
        STATE.volumeChart.update('none');
    }
    
    if (STATE.rsiChart && STATE.overlays.rsi) {
        STATE.rsiChart.data.datasets[0].data = candles.map((c, i) => ({ x: c.t, y: STATE.rsiData[i] })).filter(d => d.y !== null);
        STATE.rsiChart.data.datasets[1].data = candles.map((c, i) => ({ x: c.t, y: STATE.stochRsiData.k[i] })).filter(d => d.y !== null);
        STATE.rsiChart.data.datasets[2].data = candles.map((c, i) => ({ x: c.t, y: STATE.stochRsiData.d[i] })).filter(d => d.y !== null);
        STATE.rsiChart.update('none');
    }
}

// ============================================================
// SESSION STATS
// ============================================================
function updateSessionStats() {
    const all = STATE.signalHistory;
    const closed = all.filter(s => ['tp1','tp2','sl'].includes(s.status));
    
    const riskyCount = all.filter(s => s.category === 'risky').length;
    const neutralCount = all.filter(s => s.category === 'neutral').length;
    const safeCount = all.filter(s => s.category === 'safe').length;
    
    safeSetText('statRisky', riskyCount);
    safeSetText('statNeutral', neutralCount);
    safeSetText('statSafe', safeCount);

    if (!closed.length) {
        safeSetText('statWinRate', '--');
        safeSetText('statTotalR', '--');
        return;
    }

    const wins = closed.filter(s => s.status === 'tp1' || s.status === 'tp2');
    const wr = (wins.length / closed.length * 100).toFixed(0);
    safeSetText('statWinRate', wr + '%', wr >= 60 ? 'var(--long)' : wr >= 45 ? 'var(--warn)' : 'var(--short)');

    const totalR = closed.reduce((a,s) => {
        if (s.status === 'tp2') return a + 3.5;
        if (s.status === 'tp1') return a + 2;
        return a - 1;
    }, 0);
    const totalRStr = (totalR >= 0 ? '+' : '') + totalR.toFixed(1) + 'R';
    safeSetText('statTotalR', totalRStr, totalR >= 0 ? 'var(--long)' : 'var(--short)');
}

function updateAllUI() {
    renderMTFBias();
    renderFVGList();
    renderLiquidity();
    renderSignalHistory();
    updateSessionStats();
}

// ============================================================
// WEBSOCKET & INIT
// ============================================================
function connectWS() {
    if (STATE.ws) try { STATE.ws.close(); } catch(e) {}
    const ws = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@trade');
    STATE.ws = ws;
    let lastCU = 0, lastA = 0, tc = 0;

    ws.onopen = () => {
        const wsStatus = document.getElementById('wsStatus');
        if (wsStatus) {
            wsStatus.style.background = 'var(--long)';
            wsStatus.style.boxShadow = '0 0 8px var(--long-glow)';
        }
        if (STATE.wsReconnectTimer) { clearTimeout(STATE.wsReconnectTimer); STATE.wsReconnectTimer = null; }
    };

    ws.onmessage = (e) => {
        const d = JSON.parse(e.data);
        STATE.price = parseFloat(d.p);
        tc++;
        safeSetText('livePrice', '$' + STATE.price.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 }));
        if (STATE.openPrice24h > 0) {
            const ch = ((STATE.price / STATE.openPrice24h - 1) * 100);
            const el = document.getElementById('priceChange');
            if (el) {
                el.textContent = (ch >= 0 ? '+' : '') + ch.toFixed(2) + '%';
                el.className = ch >= 0 ? 'price-change price-up' : 'price-change price-down';
            }
        }
        const tf = STATE.currentTF;
        if (STATE.tfData[tf] && STATE.tfData[tf].length) {
            const last = STATE.tfData[tf][STATE.tfData[tf].length-1];
            last.c = STATE.price;
            if (STATE.price > last.h) last.h = STATE.price;
            if (STATE.price < last.l) last.l = STATE.price;
        }
        const now = Date.now();
        if (now - lastCU > 2000) { updateChart(); lastCU = now; }
        if (now - lastA > 10000) { runAnalysis(); lastA = now; }
        trackSignalOutcomes();
        updateCooldownBar();
    };

    ws.onerror = () => { 
        const wsStatus = document.getElementById('wsStatus');
        if (wsStatus) {
            wsStatus.style.background = 'var(--short)'; 
            wsStatus.style.boxShadow = '0 0 8px var(--short-glow)'; 
        }
    };
    
    ws.onclose = () => { 
        const wsStatus = document.getElementById('wsStatus');
        if (wsStatus) {
            wsStatus.style.background = 'var(--warn)'; 
            wsStatus.style.boxShadow = '0 0 8px rgba(255,193,7,0.4)'; 
        }
        STATE.wsReconnectTimer = setTimeout(connectWS, 3000); 
    };
}

function runAnalysis() {
    const candles = STATE.tfData[STATE.currentTF];
    if (!candles || candles.length < 50) return;
    
    updateRSIData();
    detectFVGs(candles); 
    detectOrderBlocks(candles);
    detectSwingPoints(candles); 
    detectMSSandBOS(candles);
    detectLiquidityLevels(); 
    analyzeMTFBias(); 
    analyzeWyckoffMTF();
    calculateFibonacci();
    detectSession();
    renderFVGList(); 
    renderLiquidity(); 
    renderMTFBias();
    generateSignals();
}

// ============================================================
// EVENT HANDLERS
// ============================================================
document.querySelectorAll('.tf-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
        document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const newTF = btn.dataset.tf;
        STATE.currentTF = newTF;

        if (!STATE.tfData[STATE.currentTF] || STATE.tfData[STATE.currentTF].length < 10) {
            btn.style.opacity = '0.5';
            const data = await fetchCandles(STATE.currentTF, 500);
            if (data) STATE.tfData[STATE.currentTF] = data;
            btn.style.opacity = '1';
        }
        
        updateRSIData();
        initChart();
        runAnalysis();
    });
});

document.getElementById('btnLine').addEventListener('click', () => { STATE.chartType = 'line'; document.getElementById('btnLine').classList.add('active'); document.getElementById('btnCandles').classList.remove('active'); initChart(); });
document.getElementById('btnCandles').addEventListener('click', () => { STATE.chartType = 'candles'; document.getElementById('btnCandles').classList.add('active'); document.getElementById('btnLine').classList.remove('active'); initChart(); });

document.querySelectorAll('.toggle-chip').forEach(chip => {
    chip.addEventListener('click', () => {
        const key = chip.dataset.overlay;
        STATE.overlays[key] = !STATE.overlays[key];
        chip.classList.toggle('on', STATE.overlays[key]);
        
        if (key === 'rsi') {
            const container = document.getElementById('rsiContainer');
            if (STATE.overlays.rsi) {
                if (container) container.style.display = 'block';
                initRSIChart();
            } else {
                if (container) container.style.display = 'none';
                if (STATE.rsiChart) {
                    STATE.rsiChart.destroy();
                    STATE.rsiChart = null;
                }
            }
            syncCharts(STATE.chart);
        } else {
            initChart();
        }
    });
});

document.getElementById('signalModal').addEventListener('click', (e) => {
    if (e.target.id === 'signalModal') closeModal();
});

async function refreshData() {
    for (const tf of Object.keys(STATE.tfData)) {
        const data = await fetchCandles(tf, 500);
        if (data) STATE.tfData[tf] = data;
    }
    updateRSIData();
    runAnalysis();
    updateSessionStats();
}

async function init() {
    const ld = document.getElementById('loadingStatus');
    try {
        setLanguage(CURRENT_LANG);
        
        if (ld) ld.textContent = t('loading_market');
        await loadAllTimeframes();
        
        if (ld) ld.textContent = 'Loading funding data...';
        await fetchFundingData();
        
        if (ld) ld.textContent = 'Analyzing market structure...';
        initPanels();
        runAnalysis();
        
        if (ld) ld.textContent = 'Initializing charts...';
        initChart();
        
        if (ld) ld.textContent = 'Loading session stats...';
        updateSessionStats();
        
        if (ld) ld.textContent = 'Connecting live feed...';
        connectWS();
        
        if ('Notification' in window && Notification.permission === 'default') Notification.requestPermission();
        
        setTimeout(() => {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) overlay.classList.add('hidden');
        }, 800);
        
        setInterval(refreshData, 5 * 60 * 1000);
        setInterval(fetchFundingData, 60 * 1000);
        setInterval(() => {
            detectSession();
            updateFundingUI();
        }, 1000);
        
    } catch (err) { 
        if (ld) ld.textContent = 'Error: ' + err.message; 
        console.error(err); 
    }
}

window.addEventListener('load', init);
</script>
</body>
</html>
